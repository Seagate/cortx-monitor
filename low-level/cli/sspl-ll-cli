#!/usr/bin/python3.6
# encoding: utf-8
"""
 Filename:          sspl-ll-cli
 Description:       CLI to send msgs to SSPL-LL service
 Creation Date:     12/02/2015
 Author:            Jake Abernathy

 Do NOT modify or remove this copyright and confidentiality notice!
 Copyright (c) 2001 - $Date: 2015/01/14 $ Seagate Technology, LLC.
 The code contained herein is CONFIDENTIAL to Seagate Technology, LLC.
 Portions are also trade secret. Any use, duplication, derivation, distribution
 or disclosure of this code, for any reason, not expressly authorized is
 prohibited. All other rights are expressly reserved by Seagate Technology, LLC.
"""

import argparse
import subprocess
import sys
import os
import re
import json
import time
from json import JSONDecoder
from pprint import pprint

# Add the top level directories
sys.path.insert(0, '/opt/seagate/cortx/sspl/low-level')
from framework.utils.config_reader import ConfigReader
from tests.manual.manual_test import ManualTest
from framework.base.sspl_constants import CLI_RESOURCE_PATH, COMMON_CONFIGS

__all__ = []
__version__ = 0.3
__date__ = '2015-12-02'
__updated__ = '2017-22-11'
program_name = os.path.basename(sys.argv[0])
program_version_message = ('%s v%s (%s)' %(program_name, __version__, __updated__))

FLAGS = re.VERBOSE | re.MULTILINE | re.DOTALL
BLANKSPACE = re.compile(r'[ \t\n\r]*', FLAGS)

# Section containing information about the system we're running on
CONF_FILE_PATH  = '/etc/sspl.conf'
SYS_INFORMATION = 'SYSTEM_INFORMATION'
CLI_TYPE        = 'cli_type'
PRODUCT        = 'product'
SSPL_LL_SETTING = 'SSPL-LL_SETTING'
CORE_PROCESSORS = 'core_processors'
ACTUATORS       = 'actuators'
SENSORS         = 'sensors'
RABBITMQINGRESSPROCESSOR = 'RABBITMQINGRESSPROCESSOR'

#GEM commands
REBOOT_ALL_SAS_EXPANDERS_CMD = 'wbcli {} "gncli exp:all reboot"'

class CLIError(Exception):
    '''Generic exception to raise and log different fatal errors.'''
    def __init__(self, msg):
        super(CLIError).__init__(type(self))
        self.msg = "E: %s" % msg

    def __str__(self):
        return self.msg

    def __unicode__(self):
        return self.msg

def main():
    '''CLI to send msgs to SSPL-LL service'''

    # Display help if no args are passed in
    if len(sys.argv) == 1:
        sys.argv.append("--help")

    program_shortdesc = __import__('__main__').__doc__.split("\n")[1]
    description = "Program for interacting with SSPL-LL service"

    # Validate configuration file for required valid values
    try:
        conf_reader = ConfigReader()

    except (IOError, ConfigReader.Error) as err:
        # We don't have logger yet, need to find log_level from conf file first
        print("[ Error ] when validating the configuration file %s :" % \
            CONF_FILE_PATH)
        print(err)
        print("Exiting ...")
        sys.exit(os.EX_USAGE)

    # Read in CLI type value from configuration file
    cli_type = conf_reader._get_value_with_default(SYS_INFORMATION, CLI_TYPE, 'CS-A').lower()
    product = conf_reader._get_value(SYS_INFORMATION, COMMON_CONFIGS.get(SYS_INFORMATION).get(PRODUCT))
    # Convert all string to lowercase in the list for ignore case sensitive
    global manTest
    if product.lower() == "ldr_r1":
        # Setup argument parser
        parser = argparse.ArgumentParser(description=description, formatter_class=argparse.RawDescriptionHelpFormatter, \
                                         add_help=False, allow_abbrev=False)
        parser.add_argument("-v", "--version", action="store_true", help="show cli version")
        try:
            # Create instance of ManualTest to publish messages
            manTest = ManualTest("RABBITMQINGRESSPROCESSOR")
        except Exception:
            print("Products only useful for verifying packages\n")
        return _init_LDR_R1(parser, program_name)

    else:
        if cli_type == "sed":
            # Setup argument parser
            parser = argparse.ArgumentParser(description=description, formatter_class=argparse.RawDescriptionHelpFormatter, \
                                             add_help=True, allow_abbrev=False)
            parser.add_argument("-v", "--version", action="store_true", help="show cli version")
            try:
                # Create instance of ManualTest to publish messages
                manTest = ManualTest("PLANECNTRLRMQEGRESSPROCESSOR")
            except Exception:
                print("CLI only useful for verifying packages\n")
            return _init_SED(parser, program_name)

        else:
            # Setup argument parser
            parser = argparse.ArgumentParser(description=description, formatter_class=argparse.RawDescriptionHelpFormatter, \
                                             add_help=False, allow_abbrev=False)
            parser.add_argument("-v", "--version", action="store_true", help="show cli version")
            try:
                # Create instance of ManualTest to publish messages
                manTest = ManualTest("RABBITMQINGRESSPROCESSOR")
            except Exception:
                print("CLI only useful for verifying packages\n")
            return _init_CS_A(parser, program_name)

def _send_raw_msg(jsonMsg, wait_for_response=True, response_wait_time=5,
                  alldata=False, indent=False, remove_results_file=True,
                  host=None, force_wait=False):
    """Update authentication fields, validate and transmit json msg"""

    # Update the authentication fields in json msg
    manTest.addAuthFields(jsonMsg)

    # Validate the msg against the schemas
    manTest.validate(jsonMsg)

    # Encode and publish
    message = json.dumps(jsonMsg, ensure_ascii=True).encode('utf8')
    manTest.basicPublish(message=message, wait_for_response=wait_for_response,
                         response_wait_time=response_wait_time, force_wait=force_wait,
                         alldata=alldata, indent=indent,
                         remove_results_file=remove_results_file, host=host)

def _send_iem_exchange(exchange, log_msg, host=None):
    """Sends an IEM on a particular rabbitmq exchange"""
    try:
        # Raw IEM sent as a string with no header authentication fields or schema validation
        manTest.basicPublish(message=log_msg, wait_for_response=False,
                             host=host)
    except Exception as ae:
        print("IEM failed on exchange: {}".format(exchange))
        print("Exception:{}".format(ae))

def _send_SED_command(request, parameters, arguments, response_wait_time, force_wait):
    file = CLI_RESOURCE_PATH + "/actuator_msgs/plane_cntrl_request.json"
    jsonMsg = json.loads(open(file).read())
    jsonMsg["message"]["actuator_request_type"]["plane_controller"]["command"] = "%s" % request
    jsonMsg["message"]["actuator_request_type"]["plane_controller"]["parameters"] = parameters
    jsonMsg["message"]["actuator_request_type"]["plane_controller"]["arguments"] = arguments

    _send_raw_msg(jsonMsg, response_wait_time=response_wait_time, indent=True, force_wait=force_wait)

def _sed_print_usage():
    print("Usage: sspl-ll-cli config [list | modify] key-management\n\t\t   drive [list | modify | erase | recover]")

def _config_parser(args):
    """Parse the initial config input"""
    #print"_config_parser args: %s" % str(args)
    if args.list == "None" or \
       args.modify == "None":
        _sed_print_usage()
        print("Choose from [list | modify] key-management\n")
        exit(0)

    return 'config %s %s %s %s %s %s' % (args.list, args.modify, \
                                        args.id, args.raid, args.node, args.debug)

def _drive_parser(args):
    """Parse the initial drive input"""
    #print"_drive_parser args: %s" % str(args)
    if args.list == "None" and \
       args.modify == "None" and \
       args.erase == "None" and \
       args.recover == "None":
        _sed_print_usage()
        print("Choose from [list | modify | erase | recover]\n")
        exit(0)

    return 'drive %s %s %s %s %s %s %s %s' % (args.list, args.modify, args.erase, args.recover, \
                                              args.id, args.raid, args.node, args.debug)

def _verify_parser(args):
    """Parse the initial verify input"""
    #print"_verify_parser args: %s" % str(args)
    if args.config is None:
        args.config = "/etc/sspl.conf"

    return 'verify %s %s %s' % (args.checkdeps, args.config, args.autoinstall)

def _init_SED(parser, program_name):
    """Initialize options for Castor CS-A project"""
    # Entry point of SED key-management

    SED_subparser = parser.add_subparsers(title = 'Available Command Sets', description='SED Key Management')

    config_parser = SED_subparser.add_parser("config", add_help=True)
    config_parser.add_argument("list", nargs='?', type=str, default="None", help="list key-management")
    config_parser.add_argument("modify", nargs='?', type=str, default="None", help="modify key-management")
    config_parser.add_argument("-i", "--id", metavar="ID", help="Individual drive identifier, wwn or serial number")
    config_parser.add_argument("-r", "--raid", help="RAID group to apply operation")
    config_parser.add_argument("-n", "--node", help="System node to apply operation")
    config_parser.add_argument("-d", "--debug", metavar="ID", help="Show additional drive information, wwn or serial number")
    config_parser.set_defaults(func=_config_parser)

    drive_parser = SED_subparser.add_parser("drive", add_help=True)
    drive_parser.add_argument("list", nargs='?', type=str, default="None", help="list key-management")
    drive_parser.add_argument("modify", nargs='?', type=str, default="None", help="modify key-management")
    drive_parser.add_argument("erase", nargs='?', type=str, default="None", help="erase key-management")
    drive_parser.add_argument("recover", nargs='?', type=str, default="None", help="recover key-management")
    drive_parser.add_argument("-i", "--id", metavar="ID", help="Individual drive identifier, wwn or serial number")
    drive_parser.add_argument("-r", "--raid", help="RAID group to apply operation")
    drive_parser.add_argument("-n", "--node", help="System node to apply operation")
    drive_parser.add_argument("-d", "--debug", metavar="ID", help="Show additional drive information, wwn or serial number")
    drive_parser.set_defaults(func=_drive_parser)

    verify_parser = SED_subparser.add_parser("verify", add_help=True)
    verify_parser.add_argument("-c", "--config", metavar="FILE", help="Configuration file, defaults to /etc/sspl.conf")
    verify_parser.add_argument("-a", "--autoinstall", action="store_true", help="Automatically attempt to install required packages")
    verify_parser.set_defaults(func=_verify_parser)

    try:
        # Process arguments
        args = parser.parse_args()
        values = args.func(args).split()
        if "help" in values:
            parser.print_help()
            return 1

        # Branch off and handle config or drive commands
        if values[0] == "config":
            success, request, parameters, arguments, response_wait_time, force_wait = _process_SED_config(values[1:])
        elif values[0] == "drive":
            success, request, parameters, arguments, response_wait_time, force_wait = _process_SED_drive(values[1:])

        # If successful then send the msg
        if success:
            if request:
                _send_SED_command(request, parameters, arguments, response_wait_time, force_wait)
        else:
            if request == "cancel":
                print("Operation cancelled")
            else:
                print("A problem occurred, try again.")

    except KeyboardInterrupt:
        print("\nHalting sspl-ll-cli\n")
        return 0
    except Exception as e:
        print("An error occurred: %s" % str(e))
        _sed_print_usage()

def _get_sed_input(command, available_commands, get_value, verify_value, value_list):
    """Prompt the user for a value for an item listed in available_commands"""
    input = "N/A"
    value = "N/A"

    while len(input) == 0 or \
        input not in available_commands:
        input = input("%s: \n\t%s\nsspl-ll-cli> " % (command, available_commands)).strip()

    if input == "cancel":
        return input, None

    command_list = available_commands.replace("{","").replace("}","").replace(" ", "").split(",")
    command_index = command_list.index(input)

    # Get a value for the selected input and verify it's in the value_list
    if get_value:
        valid_values = value_list[command_index]
        value = input("Set '%s' to [%s]: " % (input, valid_values))
        if verify_value:
            while len(value) == 0 or \
                    (value not in valid_values and \
                       "Any" not in valid_values):
                value = input("Available choices: \n\t[%s]\nsspl-ll-cli> " % valid_values).strip()
    return input, value

def _process_SED_drive(values):
    """Process values from command line for drive requests"""
    try:
        #print "drive values: %s" % values
        for idx, value in enumerate(values):
            if values[idx]== "None":
                values[idx] = None
        params = {'drive_id':values[4], 'raid_id': values[5], 'node_id':values[6], 'debug_id': values[7]}
        arguments = {}

        # If we're sending request to all nodes then force a 7 second delay and then read from rabbitmq
        if values[6] == "None":
            force_wait = True
            response_timeout = 45
        else:
            force_wait = False
            response_timeout = 30

        # Drive list key-management
        if values[0] == "list":
            # Only care about arguments to identify the scope of the request, todo make these configurable via cli
            arguments = {'condition': None, 'fromdb': None, 'ignoreha': False}
            request = "status"

        elif values[0] == "modify":
            input, value = _get_sed_input("Available drive-level settings", "{security}", \
                                           True, True, ["key-rotate, unlock"])
            if input == "security":
                if value == "key-rotate":
                    request = "%s %s %s" % (values[0], input, value)

                elif value == "unlock":
                    request = "%s %s %s" % (values[0], input, value)

        elif values[0] == "erase":
            # Only care about paramaters to identify the scope of the request
            request = "%s" % values[0]

            # Verify that the user really wants to erase
            response = input("Drive erase confirm: \n\t[yes, no]\nsspl-ll-cli> ").strip()
            if response == "yes":
                arguments = {"recovery": None}
            else:
                return False, "cancel", None, None

        elif values[0] == "recover":
            # Only care about paramaters to identify the scope of the request
            request = "%s" % values[0]

        return True, request, params, arguments, response_timeout, force_wait

    except Exception as e:
        print("_process_SED_drive, Error occurred: %s" % str(e))

def _process_SED_config(values):
    """Process values from command line for config requests
     @return: success, request, parameters, response_wait_time"""
    try:
        #print "config values: %s" % values
        params = {'drive_id':values[2], 'raid_id': values[3], 'node_id':values[4], 'debug_id': values[5]}

        # If we're sending request to all nodes then force a 7 second delay and then read from rabbitmq
        if values[4] == "None":
            force_wait = True
            response_timeout = 45
        else:
            force_wait = False
            response_timeout = 30

        # Config list key-management
        if values[0] == "list":
            if values[1] == "key-management":
                return True, "list system-level key-management", params, response_timeout, force_wait

        # Config modify key-management
        elif values[0] == "modify":
            if values[1] == "key-management":
                input, value = _get_sed_input("Available system-level settings", "{kind, server, recovery, fips}", \
                                               True, True, ["off | ko | kmpi | local", "Any URI", \
                                                            "on | off | password", "on | off"])
                # If input is 'recovery' then get passwords
                if input == "recovery":
                    if value == "on" or \
                        value == "password":

                        display_pass = "new-password"
                        if value == "password":
                            display_pass = "old-password"

                        on_input1, pass1 = _get_sed_input("Select 'recovery' %s option" % value, "{%s, cancel}" % display_pass, \
                                                    True, True, ["Any alpha-numeric string"])
                        if on_input1 == "cancel":
                            return False, "cancel", params, None, None

                        if value == "on":
                            display_pass = "repeat-password"
                        else:
                            display_pass = "new-password"
                        if on_input1:
                            on_input2, pass2 = _get_sed_input("Select 'recovery' %s option" % value, "{%s, cancel}" % display_pass, \
                                                              True, True, ["Any alpha-numeric string"])
                        if not on_input1 or \
                            not on_input2:
                            return False, None, None, None, None
                        # Make sure the passwords match
                        if value == "on" and \
                            pass1 != pass2:
                            print("Error passwords do not match")
                            return False, None, None, None, None

                        if on_input2 == "cancel":
                            return False, "cancel", None, None, None

                        # Put together the request with passwords
                        if value == "password":
                            request = "%s %s %s %s %s %s" % (values[0], values[1], input, value, pass1, pass2)
                        else:
                            request = "%s %s %s %s %s" % (values[0], values[1], input, value, pass1)
                    else:
                        request = "%s %s %s %s off" % (values[0], values[1], input, value)

                # Put together the request
                else:
                    request = "%s %s %s %s" % (values[0], values[1], input, value)

                return True, request, params, response_timeout, force_wait

    except Exception as e:
        print("_process_SED_config, Error occurred: %s" % str(e))
    return False, None, None, None, None

def _init_CS_A(parser, program_name):
    """Initialize options for Castor CS-A project"""
    parser.add_argument("--help", action="store_true", help="display this help message and exit")
    parser.add_argument("-a", "--all", action="store_true", help="display all the data received in responses")
    parser.add_argument("-h", "--human", action="store_true", help="display responses with indentation for readability")
    parser.add_argument("--generic", metavar="COMMAND", help="execute from command line ie 'SWAP ON'")
    parser.add_argument("--pdu", metavar="COMMAND", help="send command to PDU. \
                          ie 'show outlets details'")
    parser.add_argument("--restartthread", metavar="NAME", help="restart an internal thread within the service")
    parser.add_argument("--servicename", metavar="NAME", help="name of service to apply request")
    parser.add_argument("--servicereq", metavar="REQUEST", help="start/stop/restart/status/enable/disable request")
    parser.add_argument("--ipmicmd", metavar="COMMAND", help="on/off/cycle/status (chassis power cmds or status)")
    parser.add_argument("--ipmiIP", metavar="IP", help="IP to apply command")
    parser.add_argument("--hdparm", metavar="COMMAND", help="ie \"-I /dev/sda | grep 'Serial Number:'\"")
    parser.add_argument("--iemlog", metavar="MESSAGE", help="IEM log.  ie 'IEC: 001002001: Rules Engine...'")
    parser.add_argument("--iemloglevel", metavar="LEVEL", help="IEM log level.  ie LOG_CRIT, LOG_ERR, LOG_WARNING")
    parser.add_argument("--iemhost", metavar="HOST", help="IEM receiver. ie 10.22.192.100, default localhost")
    parser.add_argument("--iemexchange", metavar="EXCHNG", help="RabbitMQ exchange. ie sspl_iem, default sspl-iem")
    parser.add_argument("--fsstats", metavar="FSFIDKEY", help="display total/free space on Motr, ie --fsstats 4")

    group = parser.add_mutually_exclusive_group()
    group.add_argument("--smrdata", action="store_true", help="log SMR drive register data")
    group.add_argument("--cpudata", action="store_true", help="display CPU data")
    group.add_argument("--hostdata", action="store_true", help="display host data")
    group.add_argument("--mountdata", action="store_true", help="display local mount data")
    group.add_argument("--interfacedata", action="store_true", help="display network interface data")
    group.add_argument("--raiddata", action="store_true", help="display RAID data")

    parser.add_argument("--fromstdin", action="store_true", help="read JSON msg(s) from stdin")
    parser.add_argument("--fromfile", metavar="FILE", help="read JSON msg(s) from file")

    parser.add_argument("--stopdrive", metavar="DRIVE", help="power down a drive.  ie /dev/sda1")
    parser.add_argument("--startdrive", metavar="DRIVE", help="power up a drive.  ie /dev/sda1")
    parser.add_argument("--resetdrive", metavar="DRIVE", help="reset drive by cycling its power.  ie /dev/sda1")
    parser.add_argument("--smart", metavar="DRIVE", help="schedule a SMART test on a drive. ie /dev/sda1 or '*'")
    parser.add_argument("--drvmngr", metavar="DRIVE", help="display drivemanager's status. ie /dev/sda1 or '*'")
    parser.add_argument("--hpi", metavar="DRIVE", help="display HPI status. ie /dev/sda1 or '*'")
    parser.add_argument("--setdrivestatus", metavar="DRIVE --status [STATUS] --reason [REASON]",
                        help="set status and reason of a drive. ie /dev/sda1 or " \
                        "s/n, --status STATUS --reason REASON")
    parser.add_argument("--status", metavar="STATUS", help="set the status field used in --setdrivestatus")
    parser.add_argument("--reason", metavar="REASON", help="set the reason field used in --setdrivestatus")

    parser.add_argument("--setdriveLED", metavar="DRIVE --LEDstate [LEDSTATE]",
                        help="set LED state of a drive. ie /dev/sda1 or " \
                        "s/n, --LEDstate LEDSTATE")
    parser.add_argument("--getdriveLED", metavar="DRIVE",
                        help="get LED state of a drive. ie /dev/sda1 or s/n")
    parser.add_argument("--LEDstate", metavar="LEDSTATE", help="FAULT_ON, FAULT_OFF, IDENTIFY_ON, IDENTIFY_OFF,"\
                        "PULSE_SLOW_ON, PULSE_SLOW_OFF, PULSE_FAST_ON, PULSE_FAST_OFF")
    group.add_argument("--expreset", action="store_true", help="trigger expander reset")
    parser.add_argument("--simulate", metavar="IDENTIFIER --event [EVENT]",
                        help="simulate an event. ie /dev/sda1 or s/n " \
                        "--event EVENT")
    parser.add_argument("--event", metavar="EVENT", help="DRIVE_INSTALL, DRIVE_UNINSTALL, EXP_RESET, SMART_FAILURE." \
                        "  ie --simulate all-drives --event EXP_RESET")
    parser.add_argument("--config", metavar="CONFIG", help="Configuration file used to check dependencies.")
    parser.add_argument("--autoinstall", action="store_true", help="Automatically attempt to install required packages.")
    return _process_arguments(parser, program_name)

def _init_LDR_R1(parser, program_name):
    """Initialize options for Castor LDR_R1 project"""
    parser.add_argument("--help", action="store_true", help="display this help message and exit")
    parser.add_argument("-a", "--all", action="store_true", help="display all the data received in responses")
    parser.add_argument("-h", "--human", action="store_true", help="display responses with indentation for readability")
    parser.add_argument("--restartthread", metavar="NAME", help="restart an internal thread within the service")
    parser.add_argument("--servicename", metavar="NAME", help="name of service to apply request")
    parser.add_argument("--servicereq", metavar="REQUEST", help="start/stop/restart/status/enable/disable request")
    parser.add_argument("--ipmicmd", metavar="COMMAND", help="on/off/cycle/status (chassis power cmds or status)")
    parser.add_argument("--ipmiIP", metavar="IP", help="IP to apply command")
    parser.add_argument("--iemlog", metavar="MESSAGE", help="IEM log.  ie 'IEC: 001002001: Rules Engine...'")
    parser.add_argument("--iemloglevel", metavar="LEVEL", help="IEM log level.  ie LOG_CRIT, LOG_ERR, LOG_WARNING")
    parser.add_argument("--iemhost", metavar="HOST", help="IEM receiver. ie 10.22.192.100, default localhost")
    parser.add_argument("--iemexchange", metavar="EXCHNG", help="RabbitMQ exchange. ie sspl_iem, default sspl-iem")
    parser.add_argument("--fsstats", metavar="FSFIDKEY", help="display total/free space on Motr, ie --fsstats 4")
    group = parser.add_mutually_exclusive_group()
    group.add_argument("--cpudata", action="store_true", help="display CPU data")
    group.add_argument("--hostdata", action="store_true", help="display host data")
    group.add_argument("--mountdata", action="store_true", help="display local mount data")
    group.add_argument("--interfacedata", action="store_true", help="display network interface data")
    group.add_argument("--raiddata", action="store_true", help="display RAID data")
    parser.add_argument("--fromstdin", action="store_true", help="read JSON msg(s) from stdin")
    parser.add_argument("--fromfile", metavar="FILE", help="read JSON msg(s) from file")
    parser.add_argument("--smart", metavar="DRIVE", help="schedule a SMART test on a drive. ie /dev/sda1 or '*'")
    parser.add_argument("--config", metavar="CONFIG", help="Configuration file used to check dependencies.")
    parser.add_argument("--autoinstall", action="store_true", help="Automatically attempt to install required packages.")
    return _process_arguments(parser, program_name)

def _process_arguments(parser, program_name):
    # Processing arguments for _init_CS_A and _init_LDR_R1 functions.
    try:
        args = parser.parse_args()
        if args.version:
            print(program_version_message)

        if args.help:
            parser.print_help()

        elif hasattr(args, 'pdu') and args.pdu:
            # Load a PDU message from the manual tests directory and update it with args.pdu
            file = CLI_RESOURCE_PATH + "/actuator_msgs/node_cntrl_pdu.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["node_controller"]["node_request"] = "PDU: {}".format(args.pdu)
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human, force_wait=True, response_wait_time=30)

        elif hasattr(args, 'generic') and args.generic:
            # Load a generic SSPL message from the manual tests directory and update it with args.generic
            file = CLI_RESOURCE_PATH + "/actuator_msgs/node_cntrl_sspl.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["node_controller"]["node_request"] = "SSPL: {}".format(args.generic)
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human, response_wait_time=60)

        elif hasattr(args, 'stopdrive') and args.stopdrive:
            # Load a stop drive message from the manual tests directory and update it with args.stopdrive
            file = CLI_RESOURCE_PATH + "/actuator_msgs/node_cntrl_stop_drive.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["node_controller"]["node_request"] = "STOP_DRIVE: {}".format(args.stopdrive)
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human, response_wait_time=60)

        elif hasattr(args, 'startdrive') and args.startdrive:
            # Load a start drive message from the manual tests directory and update it with args.startdrive
            file = CLI_RESOURCE_PATH + "/actuator_msgs/node_cntrl_start_drive.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["node_controller"]["node_request"] = "START_DRIVE: {}".format(args.startdrive)
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human, response_wait_time=60)

        elif hasattr(args, 'resetdrive') and args.resetdrive:
            # Load a reset drive message from the manual tests directory and update it with args.resetdrive
            file = CLI_RESOURCE_PATH + "/actuator_msgs/node_cntrl_reset_drive.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["node_controller"]["node_request"] = "RESET_DRIVE: {}".format(args.resetdrive)
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human, response_wait_time=60)

        elif hasattr(args, 'smart') and args.smart:
            # Load a smart test message from the manual tests directory and update it with args.smart
            file = CLI_RESOURCE_PATH + "/actuator_msgs/node_cntrl_smart_test.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["node_controller"]["node_request"] = "SMART_TEST: {}".format(args.smart)
            jsonMsg["message"]["actuator_request_type"]["node_controller"]["resource"] = "{}".format(args.smart)
            print("\nInitiating SMART tests.  This can take several minutes...\n")
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human, response_wait_time=300,
                          force_wait=True)

        elif hasattr(args, 'drvmngr') and args.drvmngr:
            # Load a drivemanager status message from the manual tests directory and update it with args.drvmngr
            file = CLI_RESOURCE_PATH + "/actuator_msgs/node_cntrl_drvmngr_status.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["node_controller"]["node_request"] = "DRVMNGR_STATUS: {}".format(args.drvmngr)
            force_wait = False
            wait_time = 3
            if "*" in str(args.drvmngr):
                wait_time = 30
                force_wait = True
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human, response_wait_time=wait_time,
                          force_wait=force_wait)

        elif hasattr(args, 'hpi') and args.hpi:
            # Load a reset hpi status message from the manual tests directory and update it with args.hpi
            file = CLI_RESOURCE_PATH + "/actuator_msgs/node_cntrl_hpi_status.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["node_controller"]["node_request"] = "HPI_STATUS: {}".format(args.hpi)
            force_wait = False
            wait_time = 3
            if "*" in str(args.hpi):
                wait_time = 30
                force_wait = True
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human, response_wait_time=wait_time,
                          force_wait=force_wait)

        elif hasattr(args, 'getdriveLED') and args.getdriveLED:
            # Load a node controller LED message from the manual tests directory and update it with args.getdriveLED
            file = CLI_RESOURCE_PATH + "/actuator_msgs/node_cntrl_LED.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["node_controller"]["node_request"] = "LED: get {}".format(args.getdriveLED)
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human, response_wait_time=5)

        elif hasattr(args, 'setdriveLED') and args.setdriveLED:
            # Load a node controller LED message from the manual tests directory and update it with args
            if not args.LEDstate:
                print("Error: must provide a LED state --LEDstate LEDSTATE when using --setdriveLED")
                return

            if args.LEDstate not in ["FAULT_ON", "FAULT_OFF", "IDENTIFY_ON",
                                     "IDENTIFY_OFF", "PULSE_SLOW_ON", "PULSE_SLOW_OFF",
                                     "PULSE_FAST_ON", "PULSE_FAST_OFF"]:
                print("Possible LED states: FAULT_ON, FAULT_OFF, IDENTIFY_ON, IDENTIFY_OFF," \
                      "PULSE_SLOW_ON, PULSE_SLOW_OFF, PULSE_FAST_ON, PULSE_FAST_OFF")
                return

            file = CLI_RESOURCE_PATH + "/actuator_msgs/node_cntrl_LED.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["node_controller"]["node_request"] = "LED: set {} {}" \
                        .format(args.setdriveLED, args.LEDstate)
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human, response_wait_time=5)

        elif hasattr(args, 'simulate') and args.simulate:
            # Load a node controller SIM message from the manual tests directory and update it with args
            if not args.event:
                print("Error: must provide an event to simulate --event EVENT when using --simulate")
                return

            if args.event not in ["DRIVE_INSTALL", "DRIVE_UNINSTALL", "EXP_RESET", "SMART_FAILURE"]:
                print("Possible simulated EVENTS: DRIVE_INSTALL, DRIVE_UNINSTALL, EXP_RESET, SMART_FAILURE")
                return

            file = CLI_RESOURCE_PATH + "/actuator_msgs/node_cntrl_simulate_drive.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["node_controller"]["node_request"] = "SIMULATE: {} {}" \
                        .format(args.event, args.simulate)

            # Don't wait for a response if requesting SMART failure as it just sets a flag in SSPL
            if args.event == "SMART_FAILURE":
                print("\nSMART failure flagged which will affect the next request sent to run a SMART test.\n")
                _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human, wait_for_response=False)
            else:
                _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human, response_wait_time=30)

        elif hasattr(args, 'setdrivestatus') and args.setdrivestatus:
            # Load a HDS logging message from the manual tests directory and update it with args
            if not args.status:
                print("Error: must provide a status --status STATUS when using --setdrivestatus")
                return

            if not args.reason:
                print("Error: must provide a reason --reason REASON when using --setdrivestatus")
                return

            drive = str(args.setdrivestatus)
            status = str(args.status)
            reason = str(args.reason)

            if drive.startswith("/"):
                print("Retrieving serial number using device name with hdparm tool")
                # Build the desired command using hdparm tool
                command = "/usr/sbin/hdparm -I {} | grep 'Serial Number:'".format(drive)
                print(("executing command: %s" % command))

                # Run the command and get the response and error returned
                process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                hdparm_response, error = process.communicate()

                # If an error exists stop here and return the response
                if error:
                    drive = "FAKE_TEST_SN"
                    print(("Failed to lookup s/n: {}".format(error)))
                    print(("Ignoring and using a test s/n: %s" % drive))
                else:
                    # Parse out "Serial Number:" from hdparm result to obtain serial number
                    drive = hdparm_response[15:].strip()
                    print(("Successfully retrieved s/n: %s" % drive))

            log_msg = "IEC: 038001001: Halon Disk Status: {'status': '%s', 'reason': '%s'," \
                        "'serial_number': '%s'}" % (status, reason, drive)
            print(("log_msg: %s" % log_msg))

            file = CLI_RESOURCE_PATH + "/actuator_msgs/HDS_logging.json"
            jsonMsg = json.loads(open(file).read())

            print(("    log_msg: %s" % log_msg))
            jsonMsg["message"]["actuator_request_type"]["logging"]["log_msg"] = "{}".format(log_msg)
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human)

        elif hasattr(args, 'restartthread') and args.restartthread:
            # Load a restart thread message from the manual tests directory and update it with args.restartthread
            file = CLI_RESOURCE_PATH + "/actuator_msgs/thread_cntrl_restart.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["thread_controller"]["module_name"] = "{}".format(args.restartthread)
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human)

        elif (hasattr(args, 'servicename') and args.servicename) or (hasattr(args, 'servicereq') and args.servicereq):
            if not args.servicename:
                print("Error: must provide a service name to apply request using --servicename NAME")
                return

            if not args.servicereq:
                print("Error: must provide a request to apply to the service using --servicereq REQUEST")
                print("       where REQUEST must be one of: start/stop/restart/status/enable/disable")
                return

            if args.servicereq not in ['start', 'stop', 'restart', 'status', 'enable', 'disable']:
                print("Error: Service request must be one of: start/stop/restart/status/enable/disable")
                return

            if ".service" not in args.servicename:
                args.servicename += ".service"

            # Load a service controller message from the manual tests directory and update it with args.servicename & servicereq
            file = CLI_RESOURCE_PATH + "/actuator_msgs/service_cntrl_restart.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["service_controller"]["service_name"] = "{}".format(args.servicename)
            jsonMsg["message"]["actuator_request_type"]["service_controller"]["service_request"] = "{}".format(args.servicereq)
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human)

        elif (hasattr(args, 'ipmicmd') and args.ipmicmd) or (hasattr(args, 'ipmiIP') and args.ipmiIP):
            if not args.ipmiIP:
                print("Error: must provide an IP to apply using --ipmiIP IP")
                return

            if args.ipmicmd not in ['on', 'off', 'cycle', 'status']:
                print("Error: IPMI command must be one of: on/off/cycle/status")
                return

            # Load a IPMI command message from the manual tests directory and update it with args.ipmicmd & ipmiIP
            file = CLI_RESOURCE_PATH + "/actuator_msgs/node_cntrl_ipmi_status.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["node_controller"]["node_request"] = "IPMI: {} {}". \
                                    format(args.ipmiIP, args.ipmicmd)
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human)

        elif hasattr(args, 'hdparm') and args.hdparm:
            # Load a hdparm message from the manual tests directory and update it with args.hdparm
            file = CLI_RESOURCE_PATH + "/actuator_msgs/node_cntrl_hdparm.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["node_controller"]["node_request"] = "HDPARM: {}".\
                                    format(args.hdparm)
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human)

        elif (hasattr(args, 'iemlog') and args.iemlog) or (hasattr(args, 'iemloglevel') and args.iemloglevel):
            if not args.iemlog:
                print("Error: must provide an IEM message using --iemlog MESSAGE")
                return

            if not args.iemloglevel:
                print("Error: must provide a log level to apply using --iemloglevel LEVEL")
                print("       where LEVEL is one of: LOG_EMERG, LOG_ALERT, LOG_CRIT, LOG_ERR,")
                print("                              LOG_WARNING, LOG_NOTICE, LOG_INFO, LOG_DEBUG")
                return

            if args.iemloglevel not in ['LOG_EMERG', 'LOG_ALERT', 'LOG_CRIT', 'LOG_ERR', \
                                        'LOG_WARNING', 'LOG_NOTICE', 'LOG_INFO', 'LOG_DEBUG']:
                print("Error: IEM log level must be one of: LOG_EMERG, LOG_ALERT, LOG_CRIT, LOG_ERR, ")
                print("                                  LOG_WARNING, LOG_NOTICE, LOG_INFO, LOG_DEBUG")
                return

            if "IEC" not in args.iemlog:
                print("Error: IEM log must be in form: 'IEC: xxxxxxxx: {JSON data}")
                return

            # Default to standard json format with typical headers
            if not args.iemexchange:
                # Load a logging message from the manual tests directory and update it with args.iemlog
                file = CLI_RESOURCE_PATH + "/actuator_msgs/logging.json"
                jsonMsg = json.loads(open(file).read())
                jsonMsg["message"]["actuator_request_type"]["logging"]["log_level"] = "{}".\
                                                            format(args.iemloglevel)
                jsonMsg["message"]["actuator_request_type"]["logging"]["log_msg"] = "{}".\
                                                            format(args.iemlog)
                _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human,
                              wait_for_response=False, host=args.iemhost)
            else:
                log_msg = "{} {}".format(args.iemloglevel, args.iemlog)
                _send_iem_exchange(args.iemexchange, log_msg, host=args.iemhost)

        elif hasattr(args, 'smrdata') and args.smrdata:
            # Load a restart thread message from the manual tests directory and update it with SMRdriveData
            file = CLI_RESOURCE_PATH + "/actuator_msgs/thread_cntrl_restart.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["thread_controller"]["module_name"] = "SMRdriveData"
            _send_raw_msg(jsonMsg, wait_for_response=False, alldata=args.all, indent=args.human)
            print("Check logs for new SMR drive register values")

        elif hasattr(args, 'fsstats') and args.fsstats:
            # Load a node controller motr message and update it
            file = CLI_RESOURCE_PATH + "/actuator_msgs/node_cntrl_motr.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["node_controller"]["node_request"] = \
                    "MOTR: fsstats {}".format(args.fsstats)
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human, response_wait_time=30)

        elif hasattr(args, 'cpudata') and args.cpudata:
            # Load a sensor request message for cpu data from the manual tests directory and send it in
            file = CLI_RESOURCE_PATH + "/actuator_msgs/sensor_request_cpu_data.json"
            jsonMsg = json.loads(open(file).read())
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human)

        elif hasattr(args, 'hostdata') and args.hostdata:
            # Load a sensor request message for host data from the manual tests directory and send it in
            file = CLI_RESOURCE_PATH + "/actuator_msgs/sensor_request_host_update.json"
            jsonMsg = json.loads(open(file).read())
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human)

        elif hasattr(args, 'mountdata') and args.mountdata:
            # Load a sensor request message for local mount data from the manual tests directory and send it in
            file = CLI_RESOURCE_PATH + "/actuator_msgs/sensor_request_mount_data.json"
            jsonMsg = json.loads(open(file).read())
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human)

        elif hasattr(args, 'interfacedata') and args.interfacedata:
            # Load a sensor request message for network data from the manual tests directory and send it in
            file = CLI_RESOURCE_PATH + "/actuator_msgs/sensor_request_if_data.json"
            jsonMsg = json.loads(open(file).read())
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human)

        elif hasattr(args, 'raiddata') and args.raiddata:
            # Load a sensor request message for raid data from the manual tests directory and send it in
            file = CLI_RESOURCE_PATH + "/actuator_msgs/sensor_request_raid_data.json"
            jsonMsg = json.loads(open(file).read())
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human)

        elif hasattr(args, 'expreset') and args.expreset:
            # Trigger expander reset

            # Get the SG device
            command = "ls /sys/class/enclosure/*/device/scsi_generic"

            # Run the command and get the response and error returned
            process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            response, error = process.communicate()
            str.strip(error)

            if error:
                print("Error in locating enclosure device to trigger exp-reset. %s" % error)
                return process.returncode

            sg_dev = "/dev/{}".format(response.rstrip('\n'))
            command = REBOOT_ALL_SAS_EXPANDERS_CMD.format(sg_dev)

            # Run the command and get the response and error returned
            process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            response, error = process.communicate()
            str.strip(error)

            if error:
                print("Error triggering expander reset: %s" % str(error))
                return process.returncode

            if response:
                print("Triggering expander reset: %s" % str(response))

        elif hasattr(args, 'fromstdin') and args.fromstdin:
            print("Ctrl-D stop reading from stdin and transmit.  Multiple msgs can be piped in.")
            json_txt = ""
            try:
                json_txt = sys.stdin.read()
            except KeyboardInterrupt:
                pass

            if not json_txt:
                return 0

            # Load in a multiple json msgs possibly sent in from stdin
            json_list = []
            decoder = JSONDecoder()
            s_len = len(json_txt)
            _w=BLANKSPACE.match

            end = 0
            while end != s_len:
                obj, end = decoder.raw_decode(json_txt, idx=_w(json_txt, end).end())
                end = _w(json_txt, end).end()
                json_list.append(obj)

            # Send them out one by one and wait for a valid response
            for json_msg in json_list:
                _send_raw_msg(json_msg, alldata=args.all, indent=args.human, remove_results_file=False)

        elif hasattr(args, 'fromfile') and args.fromfile:
            # Load in a multiple json msgs stored in a single file
            json_list = []
            json_txt = open(args.fromfile).read()
            decoder = JSONDecoder()
            s_len = len(json_txt)
            _w=BLANKSPACE.match

            end = 0
            while end != s_len:
                obj, end = decoder.raw_decode(json_txt, idx=_w(json_txt, end).end())
                end = _w(json_txt, end).end()
                json_list.append(obj)

            # Send them out one by one and wait for a valid response
            for json_msg in json_list:
                _send_raw_msg(json_msg, alldata=args.all, indent=args.human, remove_results_file=False)

        return 0
    except KeyboardInterrupt:
        return 0
    except Exception as e:
        print(("Exception trying to parse:{}".format(e)))
        indent = len(program_name) * " "
        sys.stderr.write(program_name + ": " + repr(e) + "\n")
        sys.stderr.write(indent + "  for help use --help")
        return 2

if __name__ == "__main__":
    sys.exit(main())
