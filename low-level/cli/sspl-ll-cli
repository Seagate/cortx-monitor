#!/usr/bin/python3.6
# encoding: utf-8

# Copyright (c) 2001-2020 Seagate Technology LLC and/or its Affiliates
#
# This program is free software: you can redistribute it and/or modify it under the
# terms of the GNU Affero General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
# PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License along
# with this program. If not, see <https://www.gnu.org/licenses/>. For any questions
# about this software or licensing, please email opensource@seagate.com or
# cortx-questions@seagate.com.

"""
  Description:       CLI to send msgs to SSPL-LL service
 """

import argparse
import subprocess
import sys
import os
import re
import json
import time
from json import JSONDecoder
from pprint import pprint

from framework.utils.config_reader import ConfigReader
from tests.manual.manual_test import ManualTest
from framework.base.sspl_constants import CLI_RESOURCE_PATH, COMMON_CONFIGS

__all__ = []
__version__ = 0.3
__date__ = '2015-12-02'
__updated__ = '2017-22-11'
program_name = os.path.basename(sys.argv[0])
program_version_message = ('%s v%s (%s)' %(program_name, __version__, __updated__))

FLAGS = re.VERBOSE | re.MULTILINE | re.DOTALL
BLANKSPACE = re.compile(r'[ \t\n\r]*', FLAGS)

# Section containing information about the system we're running on
CONF_FILE_PATH  = '/etc/sspl.conf'
SYS_INFORMATION = 'SYSTEM_INFORMATION'
CLI_TYPE        = 'cli_type'
PRODUCT        = 'product'
SSPL_LL_SETTING = 'SSPL-LL_SETTING'
CORE_PROCESSORS = 'core_processors'
ACTUATORS       = 'actuators'
SENSORS         = 'sensors'
RABBITMQINGRESSPROCESSOR = 'RABBITMQINGRESSPROCESSOR'

#GEM commands
REBOOT_ALL_SAS_EXPANDERS_CMD = 'wbcli {} "gncli exp:all reboot"'

class CLIError(Exception):
    '''Generic exception to raise and log different fatal errors.'''
    def __init__(self, msg):
        super(CLIError).__init__(type(self))
        self.msg = "E: %s" % msg

    def __str__(self):
        return self.msg

    def __unicode__(self):
        return self.msg

def main():
    '''CLI to send msgs to SSPL-LL service'''

    # Display help if no args are passed in
    if len(sys.argv) == 1:
        sys.argv.append("--help")

    program_shortdesc = __import__('__main__').__doc__.split("\n")[1]
    description = "Program for interacting with SSPL-LL service"

    # Validate configuration file for required valid values
    try:
        conf_reader = ConfigReader()

    except (IOError, ConfigReader.Error) as err:
        # We don't have logger yet, need to find log_level from conf file first
        print("[ Error ] when validating the configuration file %s :" % \
            CONF_FILE_PATH)
        print(err)
        print("Exiting ...")
        sys.exit(os.EX_USAGE)

    # Read in CLI type value from configuration file
    cli_type = conf_reader._get_value_with_default(SYS_INFORMATION, CLI_TYPE, 'CS-A').lower()
    product = conf_reader._get_value(SYS_INFORMATION, COMMON_CONFIGS.get(SYS_INFORMATION).get(PRODUCT))
    # Convert all string to lowercase in the list for ignore case sensitive
    global manTest
    if product.lower() == "ldr_r1":
        # Setup argument parser
        parser = argparse.ArgumentParser(description=description, formatter_class=argparse.RawDescriptionHelpFormatter, \
                                         add_help=False, allow_abbrev=False)
        parser.add_argument("-v", "--version", action="store_true", help="show cli version")
        try:
            # Create instance of ManualTest to publish messages
            manTest = ManualTest("RABBITMQINGRESSPROCESSOR")
        except Exception:
            print("Products only useful for verifying packages\n")
        return _init_LDR_R1(parser, program_name)

    else:
        if cli_type == "sed":
            # Setup argument parser
            parser = argparse.ArgumentParser(description=description, formatter_class=argparse.RawDescriptionHelpFormatter, \
                                             add_help=True, allow_abbrev=False)
            parser.add_argument("-v", "--version", action="store_true", help="show cli version")
            try:
                # Create instance of ManualTest to publish messages
                manTest = ManualTest("PLANECNTRLRMQEGRESSPROCESSOR")
            except Exception:
                print("CLI only useful for verifying packages\n")
            return _init_SED(parser, program_name)

        else:
            # Setup argument parser
            parser = argparse.ArgumentParser(description=description, formatter_class=argparse.RawDescriptionHelpFormatter, \
                                             add_help=False, allow_abbrev=False)
            parser.add_argument("-v", "--version", action="store_true", help="show cli version")
            try:
                # Create instance of ManualTest to publish messages
                manTest = ManualTest("RABBITMQINGRESSPROCESSOR")
            except Exception:
                print("CLI only useful for verifying packages\n")
            return _init_CS_A(parser, program_name)

def _send_raw_msg(jsonMsg, wait_for_response=True, response_wait_time=5,
                  alldata=False, indent=False, remove_results_file=True,
                  host=None, force_wait=False):
    """Update authentication fields, validate and transmit json msg"""

    # Update the authentication fields in json msg
    manTest.addAuthFields(jsonMsg)

    # Validate the msg against the schemas
    manTest.validate(jsonMsg)

    # Encode and publish
    message = json.dumps(jsonMsg, ensure_ascii=True).encode('utf8')
    manTest.basicPublish(message=message, wait_for_response=wait_for_response,
                         response_wait_time=response_wait_time, force_wait=force_wait,
                         alldata=alldata, indent=indent,
                         remove_results_file=remove_results_file, host=host)

def _send_iem_exchange(exchange, log_msg, host=None):
    """Sends an IEM on a particular rabbitmq exchange"""
    try:
        # Raw IEM sent as a string with no header authentication fields or schema validation
        manTest.basicPublish(message=log_msg, wait_for_response=False,
                             host=host)
    except Exception as ae:
        print("IEM failed on exchange: {}".format(exchange))
        print("Exception:{}".format(ae))

def _send_SED_command(request, parameters, arguments, response_wait_time, force_wait):
    file = CLI_RESOURCE_PATH + "/actuator_msgs/plane_cntrl_request.json"
    jsonMsg = json.loads(open(file).read())
    jsonMsg["message"]["actuator_request_type"]["plane_controller"]["command"] = "%s" % request
    jsonMsg["message"]["actuator_request_type"]["plane_controller"]["parameters"] = parameters
    jsonMsg["message"]["actuator_request_type"]["plane_controller"]["arguments"] = arguments

    _send_raw_msg(jsonMsg, response_wait_time=response_wait_time, indent=True, force_wait=force_wait)

def _sed_print_usage():
    print("Usage: sspl-ll-cli config [list | modify] key-management\n\t\t   drive [list | modify | erase | recover]")

def _config_parser(args):
    """Parse the initial config input"""
    #print"_config_parser args: %s" % str(args)
    if args.list == "None" or \
       args.modify == "None":
        _sed_print_usage()
        print("Choose from [list | modify] key-management\n")
        exit(0)

    return 'config %s %s %s %s %s %s' % (args.list, args.modify, \
                                        args.id, args.raid, args.node, args.debug)

def _drive_parser(args):
    """Parse the initial drive input"""
    #print"_drive_parser args: %s" % str(args)
    if args.list == "None" and \
       args.modify == "None" and \
       args.erase == "None" and \
       args.recover == "None":
        _sed_print_usage()
        print("Choose from [list | modify | erase | recover]\n")
        exit(0)

    return 'drive %s %s %s %s %s %s %s %s' % (args.list, args.modify, args.erase, args.recover, \
                                              args.id, args.raid, args.node, args.debug)

def _verify_parser(args):
    """Parse the initial verify input"""
    #print"_verify_parser args: %s" % str(args)
    if args.config is None:
        args.config = "/etc/sspl.conf"

    return 'verify %s %s %s' % (args.checkdeps, args.config, args.autoinstall)

def _init_SED(parser, program_name):
    """Initialize options for Castor CS-A project"""
    # Entry point of SED key-management

    SED_subparser = parser.add_subparsers(title = 'Available Command Sets', description='SED Key Management')

    config_parser = SED_subparser.add_parser("config", add_help=True)
    config_parser.add_argument("list", nargs='?', type=str, default="None", help="list key-management")
    config_parser.add_argument("modify", nargs='?', type=str, default="None", help="modify key-management")
    config_parser.add_argument("-i", "--id", metavar="ID", help="Individual drive identifier, wwn or serial number")
    config_parser.add_argument("-r", "--raid", help="RAID group to apply operation")
    config_parser.add_argument("-n", "--node", help="System node to apply operation")
    config_parser.add_argument("-d", "--debug", metavar="ID", help="Show additional drive information, wwn or serial number")
    config_parser.set_defaults(func=_config_parser)

    drive_parser = SED_subparser.add_parser("drive", add_help=True)
    drive_parser.add_argument("list", nargs='?', type=str, default="None", help="list key-management")
    drive_parser.add_argument("modify", nargs='?', type=str, default="None", help="modify key-management")
    drive_parser.add_argument("erase", nargs='?', type=str, default="None", help="erase key-management")
    drive_parser.add_argument("recover", nargs='?', type=str, default="None", help="recover key-management")
    drive_parser.add_argument("-i", "--id", metavar="ID", help="Individual drive identifier, wwn or serial number")
    drive_parser.add_argument("-r", "--raid", help="RAID group to apply operation")
    drive_parser.add_argument("-n", "--node", help="System node to apply operation")
    drive_parser.add_argument("-d", "--debug", metavar="ID", help="Show additional drive information, wwn or serial number")
    drive_parser.set_defaults(func=_drive_parser)

    verify_parser = SED_subparser.add_parser("verify", add_help=True)
    verify_parser.add_argument("-c", "--config", metavar="FILE", help="Configuration file, defaults to /etc/sspl.conf")
    verify_parser.add_argument("-a", "--autoinstall", action="store_true", help="Automatically attempt to install required packages")
    verify_parser.set_defaults(func=_verify_parser)

    try:
        # Process arguments
        args = parser.parse_args()
        values = args.func(args).split()
        if "help" in values:
            parser.print_help()
            return 1

        # Branch off and handle config or drive commands
        if values[0] == "config":
            success, request, parameters, arguments, response_wait_time, force_wait = _process_SED_config(values[1:])
        elif values[0] == "drive":
            success, request, parameters, arguments, response_wait_time, force_wait = _process_SED_drive(values[1:])

        # If successful then send the msg
        if success:
            if request:
                _send_SED_command(request, parameters, arguments, response_wait_time, force_wait)
        else:
            if request == "cancel":
                print("Operation cancelled")
            else:
                print("A problem occurred, try again.")

    except KeyboardInterrupt:
        print("\nHalting sspl-ll-cli\n")
        return 0
    except Exception as e:
        print("An error occurred: %s" % str(e))
        _sed_print_usage()

def _get_sed_input(command, available_commands, get_value, verify_value, value_list):
    """Prompt the user for a value for an item listed in available_commands"""
    input = "N/A"
    value = "N/A"

    while len(input) == 0 or \
        input not in available_commands:
        input = input("%s: \n\t%s\nsspl-ll-cli> " % (command, available_commands)).strip()

    if input == "cancel":
        return input, None

    command_list = available_commands.replace("{","").replace("}","").replace(" ", "").split(",")
    command_index = command_list.index(input)

    # Get a value for the selected input and verify it's in the value_list
    if get_value:
        valid_values = value_list[command_index]
        value = input("Set '%s' to [%s]: " % (input, valid_values))
        if verify_value:
            while len(value) == 0 or \
                    (value not in valid_values and \
                       "Any" not in valid_values):
                value = input("Available choices: \n\t[%s]\nsspl-ll-cli> " % valid_values).strip()
    return input, value

def _process_SED_drive(values):
    """Process values from command line for drive requests"""
    try:
        #print "drive values: %s" % values
        for idx, value in enumerate(values):
            if values[idx]== "None":
                values[idx] = None
        params = {'drive_id':values[4], 'raid_id': values[5], 'node_id':values[6], 'debug_id': values[7]}
        arguments = {}

        # If we're sending request to all nodes then force a 7 second delay and then read from rabbitmq
        if values[6] == "None":
            force_wait = True
            response_timeout = 45
        else:
            force_wait = False
            response_timeout = 30

        # Drive list key-management
        if values[0] == "list":
            # Only care about arguments to identify the scope of the request, todo make these configurable via cli
            arguments = {'condition': None, 'fromdb': None, 'ignoreha': False}
            request = "status"

        elif values[0] == "modify":
            input, value = _get_sed_input("Available drive-level settings", "{security}", \
                                           True, True, ["key-rotate, unlock"])
            if input == "security":
                if value == "key-rotate":
                    request = "%s %s %s" % (values[0], input, value)

                elif value == "unlock":
                    request = "%s %s %s" % (values[0], input, value)

        elif values[0] == "erase":
            # Only care about paramaters to identify the scope of the request
            request = "%s" % values[0]

            # Verify that the user really wants to erase
            response = input("Drive erase confirm: \n\t[yes, no]\nsspl-ll-cli> ").strip()
            if response == "yes":
                arguments = {"recovery": None}
            else:
                return False, "cancel", None, None

        elif values[0] == "recover":
            # Only care about paramaters to identify the scope of the request
            request = "%s" % values[0]

        return True, request, params, arguments, response_timeout, force_wait

    except Exception as e:
        print("_process_SED_drive, Error occurred: %s" % str(e))

def _process_SED_config(values):
    """Process values from command line for config requests
     @return: success, request, parameters, response_wait_time"""
    try:
        #print "config values: %s" % values
        params = {'drive_id':values[2], 'raid_id': values[3], 'node_id':values[4], 'debug_id': values[5]}

        # If we're sending request to all nodes then force a 7 second delay and then read from rabbitmq
        if values[4] == "None":
            force_wait = True
            response_timeout = 45
        else:
            force_wait = False
            response_timeout = 30

        # Config list key-management
        if values[0] == "list":
            if values[1] == "key-management":
                return True, "list system-level key-management", params, response_timeout, force_wait

        # Config modify key-management
        elif values[0] == "modify":
            if values[1] == "key-management":
                input, value = _get_sed_input("Available system-level settings", "{kind, server, recovery, fips}", \
                                               True, True, ["off | ko | kmpi | local", "Any URI", \
                                                            "on | off | password", "on | off"])
                # If input is 'recovery' then get passwords
                if input == "recovery":
                    if value == "on" or \
                        value == "password":

                        display_pass = "new-password"
                        if value == "password":
                            display_pass = "old-password"

                        on_input1, pass1 = _get_sed_input("Select 'recovery' %s option" % value, "{%s, cancel}" % display_pass, \
                                                    True, True, ["Any alpha-numeric string"])
                        if on_input1 == "cancel":
                            return False, "cancel", params, None, None

                        if value == "on":
                            display_pass = "repeat-password"
                        else:
                            display_pass = "new-password"
                        if on_input1:
                            on_input2, pass2 = _get_sed_input("Select 'recovery' %s option" % value, "{%s, cancel}" % display_pass, \
                                                              True, True, ["Any alpha-numeric string"])
                        if not on_input1 or \
                            not on_input2:
                            return False, None, None, None, None
                        # Make sure the passwords match
                        if value == "on" and \
                            pass1 != pass2:
                            print("Error passwords do not match")
                            return False, None, None, None, None

                        if on_input2 == "cancel":
                            return False, "cancel", None, None, None

                        # Put together the request with passwords
                        if value == "password":
                            request = "%s %s %s %s %s %s" % (values[0], values[1], input, value, pass1, pass2)
                        else:
                            request = "%s %s %s %s %s" % (values[0], values[1], input, value, pass1)
                    else:
                        request = "%s %s %s %s off" % (values[0], values[1], input, value)

                # Put together the request
                else:
                    request = "%s %s %s %s" % (values[0], values[1], input, value)

                return True, request, params, response_timeout, force_wait

    except Exception as e:
        print("_process_SED_config, Error occurred: %s" % str(e))
    return False, None, None, None, None

def _init_CS_A(parser, program_name):
    """Initialize options for Castor CS-A project"""
    parser.add_argument("--help", action="store_true", help="display this help message and exit")
    parser.add_argument("-a", "--all", action="store_true", help="display all the data received in responses")
    parser.add_argument("-h", "--human", action="store_true", help="display responses with indentation for readability")
    parser.add_argument("--generic", metavar="COMMAND", help="execute from command line ie 'SWAP ON'")
    parser.add_argument("--pdu", metavar="COMMAND", help="send command to PDU. \
                          ie 'show outlets details'")
    parser.add_argument("--restartthread", metavar="NAME", help="restart an internal thread within the service")
    parser.add_argument("--servicename", metavar="NAME", help="name of service to apply request")
    parser.add_argument("--servicereq", metavar="REQUEST", help="start/stop/restart/status/enable/disable request")
    parser.add_argument("--ipmicmd", metavar="COMMAND", help="on/off/cycle/status (chassis power cmds or status)")
    parser.add_argument("--ipmiIP", metavar="IP", help="IP to apply command")
    parser.add_argument("--hdparm", metavar="COMMAND", help="ie \"-I /dev/sda | grep 'Serial Number:'\"")
    parser.add_argument("--iemlog", metavar="MESSAGE", help="IEM log.  ie 'IEC: 001002001: Rules Engine...'")
    parser.add_argument("--iemloglevel", metavar="LEVEL", help="IEM log level.  ie LOG_CRIT, LOG_ERR, LOG_WARNING")
    parser.add_argument("--iemhost", metavar="HOST", help="IEM receiver. ie 10.22.192.100, default localhost")
    parser.add_argument("--iemexchange", metavar="EXCHNG", help="RabbitMQ exchange. ie sspl_iem, default sspl-iem")
    parser.add_argument("--fsstats", metavar="FSFIDKEY", help="display total/free space on Motr, ie --fsstats 4")

    group = parser.add_mutually_exclusive_group()
    group.add_argument("--smrdata", action="store_true", help="log SMR drive register data")
    group.add_argument("--cpudata", action="store_true", help="display CPU data")
    group.add_argument("--hostdata", action="store_true", help="display host data")
    group.add_argument("--mountdata", action="store_true", help="display local mount data")
    group.add_argument("--interfacedata", action="store_true", help="display network interface data")
    group.add_argument("--raiddata", action="store_true", help="display RAID data")

    parser.add_argument("--fromstdin", action="store_true", help="read JSON msg(s) from stdin")
    parser.add_argument("--fromfile", metavar="FILE", help="read JSON msg(s) from file")

    parser.add_argument("--stopdrive", metavar="DRIVE", help="power down a drive.  ie /dev/sda1")
    parser.add_argument("--startdrive", metavar="DRIVE", help="power up a drive.  ie /dev/sda1")
    parser.add_argument("--resetdrive", metavar="DRIVE", help="reset drive by cycling its power.  ie /dev/sda1")
    parser.add_argument("--smart", metavar="DRIVE", help="schedule a SMART test on a drive. ie /dev/sda1 or '*'")
    parser.add_argument("--drvmngr", metavar="DRIVE", help="display drivemanager's status. ie /dev/sda1 or '*'")
    parser.add_argument("--hpi", metavar="DRIVE", help="display HPI status. ie /dev/sda1 or '*'")
    parser.add_argument("--setdrivestatus", metavar="DRIVE --status [STATUS] --reason [REASON]",
                        help="set status and reason of a drive. ie /dev/sda1 or " \
                        "s/n, --status STATUS --reason REASON")
    parser.add_argument("--status", metavar="STATUS", help="set the status field used in --setdrivestatus")
    parser.add_argument("--reason", metavar="REASON", help="set the reason field used in --setdrivestatus")

    parser.add_argument("--setdriveLED", metavar="DRIVE --LEDstate [LEDSTATE]",
                        help="set LED state of a drive. ie /dev/sda1 or " \
                        "s/n, --LEDstate LEDSTATE")
    parser.add_argument("--getdriveLED", metavar="DRIVE",
                        help="get LED state of a drive. ie /dev/sda1 or s/n")
    parser.add_argument("--LEDstate", metavar="LEDSTATE", help="FAULT_ON, FAULT_OFF, IDENTIFY_ON, IDENTIFY_OFF,"\
                        "PULSE_SLOW_ON, PULSE_SLOW_OFF, PULSE_FAST_ON, PULSE_FAST_OFF")
    group.add_argument("--expreset", action="store_true", help="trigger expander reset")
    parser.add_argument("--simulate", metavar="IDENTIFIER --event [EVENT]",
                        help="simulate an event. ie /dev/sda1 or s/n " \
                        "--event EVENT")
    parser.add_argument("--event", metavar="EVENT", help="DRIVE_INSTALL, DRIVE_UNINSTALL, EXP_RESET, SMART_FAILURE." \
                        "  ie --simulate all-drives --event EXP_RESET")
    parser.add_argument("--config", metavar="CONFIG", help="Configuration file used to check dependencies.")
    parser.add_argument("--autoinstall", action="store_true", help="Automatically attempt to install required packages.")
    return _process_arguments(parser, program_name)

def _init_LDR_R1(parser, program_name):
    """Initialize options for Castor LDR_R1 project"""
    parser.add_argument("--help", action="store_true", help="display this help message and exit")
    parser.add_argument("-a", "--all", action="store_true", help="display all the data received in responses")
    parser.add_argument("-h", "--human", action="store_true", help="display responses with indentation for readability")
    parser.add_argument("--restartthread", metavar="NAME", help="restart an internal thread within the service")
    parser.add_argument("--servicename", metavar="NAME", help="name of service to apply request")
    parser.add_argument("--servicereq", metavar="REQUEST", help="start/stop/restart/status/enable/disable request")
    parser.add_argument("--ipmicmd", metavar="COMMAND", help="on/off/cycle/status (chassis power cmds or status)")
    parser.add_argument("--ipmiIP", metavar="IP", help="IP to apply command")
    parser.add_argument("--iemlog", metavar="MESSAGE", help="IEM log.  ie 'IEC: 001002001: Rules Engine...'")
    parser.add_argument("--iemloglevel", metavar="LEVEL", help="IEM log level.  ie LOG_CRIT, LOG_ERR, LOG_WARNING")
    parser.add_argument("--iemhost", metavar="HOST", help="IEM receiver. ie 10.22.192.100, default localhost")
    parser.add_argument("--iemexchange", metavar="EXCHNG", help="RabbitMQ exchange. ie sspl_iem, default sspl-iem")
    parser.add_argument("--fsstats", metavar="FSFIDKEY", help="display total/free space on Motr, ie --fsstats 4")
    group = parser.add_mutually_exclusive_group()
    group.add_argument("--cpudata", action="store_true", help="display CPU data")
    group.add_argument("--hostdata", action="store_true", help="display host data")
    group.add_argument("--mountdata", action="store_true", help="display local mount data")
    group.add_argument("--interfacedata", action="store_true", help="display network interface data")
    group.add_argument("--raiddata", action="store_true", help="display RAID data")
    parser.add_argument("--fromstdin", action="store_true", help="read JSON msg(s) from stdin")
    parser.add_argument("--fromfile", metavar="FILE", help="read JSON msg(s) from file")
    parser.add_argument("--smart", metavar="DRIVE", help="schedule a SMART test on a drive. ie /dev/sda1 or '*'")
    parser.add_argument("--config", metavar="CONFIG", help="Configuration file used to check dependencies.")
    parser.add_argument("--autoinstall", action="store_true", help="Automatically attempt to install required packages.")
    return _process_arguments(parser, program_name)

def _process_arguments(parser, program_name):
    # Processing arguments for _init_CS_A and _init_LDR_R1 functions.
    try:
        args = parser.parse_args()
        if args.version:
            print(program_version_message)

        if args.help:
            parser.print_help()

        elif hasattr(args, 'pdu') and args.pdu:
            # Load a PDU message from the manual tests directory and update it with args.pdu
            file = CLI_RESOURCE_PATH + "/actuator_msgs/node_cntrl_pdu.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["node_controller"]["node_request"] = "PDU: {}".format(args.pdu)
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human, force_wait=True, response_wait_time=30)

        elif hasattr(args, 'generic') and args.generic:
            # Load a generic SSPL message from the manual tests directory and update it with args.generic
            file = CLI_RESOURCE_PATH + "/actuator_msgs/node_cntrl_sspl.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["node_controller"]["node_request"] = "SSPL: {}".format(args.generic)
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human, response_wait_time=60)

        elif hasattr(args, 'stopdrive') and args.stopdrive:
            # Load a stop drive message from the manual tests directory and update it with args.stopdrive
            file = CLI_RESOURCE_PATH + "/actuator_msgs/node_cntrl_stop_drive.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["node_controller"]["node_request"] = "STOP_DRIVE: {}".format(args.stopdrive)
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human, response_wait_time=60)

        elif hasattr(args, 'startdrive') and args.startdrive:
            # Load a start drive message from the manual tests directory and update it with args.startdrive
            file = CLI_RESOURCE_PATH + "/actuator_msgs/node_cntrl_start_drive.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["node_controller"]["node_request"] = "START_DRIVE: {}".format(args.startdrive)
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human, response_wait_time=60)

        elif hasattr(args, 'resetdrive') and args.resetdrive:
            # Load a reset drive message from the manual tests directory and update it with args.resetdrive
            file = CLI_RESOURCE_PATH + "/actuator_msgs/node_cntrl_reset_drive.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["node_controller"]["node_request"] = "RESET_DRIVE: {}".format(args.resetdrive)
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human, response_wait_time=60)

        elif hasattr(args, 'smart') and args.smart:
            # Load a smart test message from the manual tests directory and update it with args.smart
            file = CLI_RESOURCE_PATH + "/actuator_msgs/node_cntrl_smart_test.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["node_controller"]["node_request"] = "SMART_TEST: {}".format(args.smart)
            jsonMsg["message"]["actuator_request_type"]["node_controller"]["resource"] = "{}".format(args.smart)
            print("\nInitiating SMART tests.  This can take several minutes...\n")
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human, response_wait_time=300,
                          force_wait=True)

        elif hasattr(args, 'drvmngr') and args.drvmngr:
            # Load a drivemanager status message from the manual tests directory and update it with args.drvmngr
            file = CLI_RESOURCE_PATH + "/actuator_msgs/node_cntrl_drvmngr_status.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["node_controller"]["node_request"] = "DRVMNGR_STATUS: {}".format(args.drvmngr)
            force_wait = False
            wait_time = 3
            if "*" in str(args.drvmngr):
                wait_time = 30
                force_wait = True
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human, response_wait_time=wait_time,
                          force_wait=force_wait)

        elif hasattr(args, 'hpi') and args.hpi:
            # Load a reset hpi status message from the manual tests directory and update it with args.hpi
            file = CLI_RESOURCE_PATH + "/actuator_msgs/node_cntrl_hpi_status.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["node_controller"]["node_request"] = "HPI_STATUS: {}".format(args.hpi)
            force_wait = False
            wait_time = 3
            if "*" in str(args.hpi):
                wait_time = 30
                force_wait = True
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human, response_wait_time=wait_time,
                          force_wait=force_wait)

        elif hasattr(args, 'getdriveLED') and args.getdriveLED:
            # Load a node controller LED message from the manual tests directory and update it with args.getdriveLED
            file = CLI_RESOURCE_PATH + "/actuator_msgs/node_cntrl_LED.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["node_controller"]["node_request"] = "LED: get {}".format(args.getdriveLED)
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human, response_wait_time=5)

        elif hasattr(args, 'setdriveLED') and args.setdriveLED:
            # Load a node controller LED message from the manual tests directory and update it with args
            if not args.LEDstate:
                print("Error: must provide a LED state --LEDstate LEDSTATE when using --setdriveLED")
                return

            if args.LEDstate not in ["FAULT_ON", "FAULT_OFF", "IDENTIFY_ON",
                                     "IDENTIFY_OFF", "PULSE_SLOW_ON", "PULSE_SLOW_OFF",
                                     "PULSE_FAST_ON", "PULSE_FAST_OFF"]:
                print("Possible LED states: FAULT_ON, FAULT_OFF, IDENTIFY_ON, IDENTIFY_OFF," \
                      "PULSE_SLOW_ON, PULSE_SLOW_OFF, PULSE_FAST_ON, PULSE_FAST_OFF")
                return

            file = CLI_RESOURCE_PATH + "/actuator_msgs/node_cntrl_LED.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["node_controller"]["node_request"] = "LED: set {} {}" \
                        .format(args.setdriveLED, args.LEDstate)
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human, response_wait_time=5)

        elif hasattr(args, 'simulate') and args.simulate:
            # Load a node controller SIM message from the manual tests directory and update it with args
            if not args.event:
                print("Error: must provide an event to simulate --event EVENT when using --simulate")
                return

            if args.event not in ["DRIVE_INSTALL", "DRIVE_UNINSTALL", "EXP_RESET", "SMART_FAILURE"]:
                print("Possible simulated EVENTS: DRIVE_INSTALL, DRIVE_UNINSTALL, EXP_RESET, SMART_FAILURE")
                return

            file = CLI_RESOURCE_PATH + "/actuator_msgs/node_cntrl_simulate_drive.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["node_controller"]["node_request"] = "SIMULATE: {} {}" \
                        .format(args.event, args.simulate)

            # Don't wait for a response if requesting SMART failure as it just sets a flag in SSPL
            if args.event == "SMART_FAILURE":
                print("\nSMART failure flagged which will affect the next request sent to run a SMART test.\n")
                _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human, wait_for_response=False)
            else:
                _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human, response_wait_time=30)

        elif hasattr(args, 'setdrivestatus') and args.setdrivestatus:
            # Load a HDS logging message from the manual tests directory and update it with args
            if not args.status:
                print("Error: must provide a status --status STATUS when using --setdrivestatus")
                return

            if not args.reason:
                print("Error: must provide a reason --reason REASON when using --setdrivestatus")
                return

            drive = str(args.setdrivestatus)
            status = str(args.status)
            reason = str(args.reason)

            if drive.startswith("/"):
                print("Retrieving serial number using device name with hdparm tool")
                # Build the desired command using hdparm tool
                command = "/usr/sbin/hdparm -I {} | grep 'Serial Number:'".format(drive)
                print(("executing command: %s" % command))

                # Run the command and get the response and error returned
                process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                hdparm_response, error = process.communicate()

                # If an error exists stop here and return the response
                if error:
                    drive = "FAKE_TEST_SN"
                    print(("Failed to lookup s/n: {}".format(error)))
                    print(("Ignoring and using a test s/n: %s" % drive))
                else:
                    # Parse out "Serial Number:" from hdparm result to obtain serial number
                    drive = hdparm_response[15:].strip()
                    print(("Successfully retrieved s/n: %s" % drive))

            log_msg = "IEC: 038001001: Halon Disk Status: {'status': '%s', 'reason': '%s'," \
                        "'serial_number': '%s'}" % (status, reason, drive)
            print(("log_msg: %s" % log_msg))

            file = CLI_RESOURCE_PATH + "/actuator_msgs/HDS_logging.json"
            jsonMsg = json.loads(open(file).read())

            print(("    log_msg: %s" % log_msg))
            jsonMsg["message"]["actuator_request_type"]["logging"]["log_msg"] = "{}".format(log_msg)
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human)

        elif hasattr(args, 'restartthread') and args.restartthread:
            # Load a restart thread message from the manual tests directory and update it with args.restartthread
            file = CLI_RESOURCE_PATH + "/actuator_msgs/thread_cntrl_restart.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["thread_controller"]["module_name"] = "{}".format(args.restartthread)
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human)

        elif (hasattr(args, 'servicename') and args.servicename) or (hasattr(args, 'servicereq') and args.servicereq):
            if not args.servicename:
                print("Error: must provide a service name to apply request using --servicename NAME")
                return

            if not args.servicereq:
                print("Error: must provide a request to apply to the service using --servicereq REQUEST")
                print("       where REQUEST must be one of: start/stop/restart/status/enable/disable")
                return

            if args.servicereq not in ['start', 'stop', 'restart', 'status', 'enable', 'disable']:
                print("Error: Service request must be one of: start/stop/restart/status/enable/disable")
                return

            if ".service" not in args.servicename:
                args.servicename += ".service"

            # Load a service controller message from the manual tests directory and update it with args.servicename & servicereq
            file = CLI_RESOURCE_PATH + "/actuator_msgs/service_cntrl_restart.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["service_controller"]["service_name"] = "{}".format(args.servicename)
            jsonMsg["message"]["actuator_request_type"]["service_controller"]["service_request"] = "{}".format(args.servicereq)
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human)

        elif (hasattr(args, 'ipmicmd') and args.ipmicmd) or (hasattr(args, 'ipmiIP') and args.ipmiIP):
            if not args.ipmiIP:
                print("Error: must provide an IP to apply using --ipmiIP IP")
                return

            if args.ipmicmd not in ['on', 'off', 'cycle', 'status']:
                print("Error: IPMI command must be one of: on/off/cycle/status")
                return

            # Load a IPMI command message from the manual tests directory and update it with args.ipmicmd & ipmiIP
            file = CLI_RESOURCE_PATH + "/actuator_msgs/node_cntrl_ipmi_status.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["node_controller"]["node_request"] = "IPMI: {} {}". \
                                    format(args.ipmiIP, args.ipmicmd)
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human)

        elif hasattr(args, 'hdparm') and args.hdparm:
            # Load a hdparm message from the manual tests directory and update it with args.hdparm
            file = CLI_RESOURCE_PATH + "/actuator_msgs/node_cntrl_hdparm.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["node_controller"]["node_request"] = "HDPARM: {}".\
                                    format(args.hdparm)
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human)

        elif (hasattr(args, 'iemlog') and args.iemlog) or (hasattr(args, 'iemloglevel') and args.iemloglevel):
            if not args.iemlog:
                print("Error: must provide an IEM message using --iemlog MESSAGE")
                return

            if not args.iemloglevel:
                print("Error: must provide a log level to apply using --iemloglevel LEVEL")
                print("       where LEVEL is one of: LOG_EMERG, LOG_ALERT, LOG_CRIT, LOG_ERR,")
                print("                              LOG_WARNING, LOG_NOTICE, LOG_INFO, LOG_DEBUG")
                return

            if args.iemloglevel not in ['LOG_EMERG', 'LOG_ALERT', 'LOG_CRIT', 'LOG_ERR', \
                                        'LOG_WARNING', 'LOG_NOTICE', 'LOG_INFO', 'LOG_DEBUG']:
                print("Error: IEM log level must be one of: LOG_EMERG, LOG_ALERT, LOG_CRIT, LOG_ERR, ")
                print("                                  LOG_WARNING, LOG_NOTICE, LOG_INFO, LOG_DEBUG")
                return

            if "IEC" not in args.iemlog:
                print("Error: IEM log must be in form: 'IEC: xxxxxxxx: {JSON data}")
                return

            # Default to standard json format with typical headers
            if not args.iemexchange:
                # Load a logging message from the manual tests directory and update it with args.iemlog
                file = CLI_RESOURCE_PATH + "/actuator_msgs/logging.json"
                jsonMsg = json.loads(open(file).read())
                jsonMsg["message"]["actuator_request_type"]["logging"]["log_level"] = "{}".\
                                                            format(args.iemloglevel)
                jsonMsg["message"]["actuator_request_type"]["logging"]["log_msg"] = "{}".\
                                                            format(args.iemlog)
                _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human,
                              wait_for_response=False, host=args.iemhost)
            else:
                log_msg = "{} {}".format(args.iemloglevel, args.iemlog)
                _send_iem_exchange(args.iemexchange, log_msg, host=args.iemhost)

        elif hasattr(args, 'smrdata') and args.smrdata:
            # Load a restart thread message from the manual tests directory and update it with SMRdriveData
            file = CLI_RESOURCE_PATH + "/actuator_msgs/thread_cntrl_restart.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["thread_controller"]["module_name"] = "SMRdriveData"
            _send_raw_msg(jsonMsg, wait_for_response=False, alldata=args.all, indent=args.human)
            print("Check logs for new SMR drive register values")

        elif hasattr(args, 'fsstats') and args.fsstats:
            # Load a node controller motr message and update it
            file = CLI_RESOURCE_PATH + "/actuator_msgs/node_cntrl_motr.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["node_controller"]["node_request"] = \
                    "MOTR: fsstats {}".format(args.fsstats)
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human, response_wait_time=30)

        elif hasattr(args, 'cpudata') and args.cpudata:
            # Load a sensor request message for cpu data from the manual tests directory and send it in
            file = CLI_RESOURCE_PATH + "/actuator_msgs/sensor_request_cpu_data.json"
            jsonMsg = json.loads(open(file).read())
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human)

        elif hasattr(args, 'hostdata') and args.hostdata:
            # Load a sensor request message for host data from the manual tests directory and send it in
            file = CLI_RESOURCE_PATH + "/actuator_msgs/sensor_request_host_update.json"
            jsonMsg = json.loads(open(file).read())
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human)

        elif hasattr(args, 'mountdata') and args.mountdata:
            # Load a sensor request message for local mount data from the manual tests directory and send it in
            file = CLI_RESOURCE_PATH + "/actuator_msgs/sensor_request_mount_data.json"
            jsonMsg = json.loads(open(file).read())
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human)

        elif hasattr(args, 'interfacedata') and args.interfacedata:
            # Load a sensor request message for network data from the manual tests directory and send it in
            file = CLI_RESOURCE_PATH + "/actuator_msgs/sensor_request_if_data.json"
            jsonMsg = json.loads(open(file).read())
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human)

        elif hasattr(args, 'raiddata') and args.raiddata:
            # Load a sensor request message for raid data from the manual tests directory and send it in
            file = CLI_RESOURCE_PATH + "/actuator_msgs/sensor_request_raid_data.json"
            jsonMsg = json.loads(open(file).read())
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human)

        elif hasattr(args, 'expreset') and args.expreset:
            # Trigger expander reset

            # Get the SG device
            command = "ls /sys/class/enclosure/*/device/scsi_generic"

            # Run the command and get the response and error returned
            process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            response, error = process.communicate()
            str.strip(error)

            if error:
                print("Error in locating enclosure device to trigger exp-reset. %s" % error)
                return process.returncode

            sg_dev = "/dev/{}".format(response.rstrip('\n'))
            command = REBOOT_ALL_SAS_EXPANDERS_CMD.format(sg_dev)

            # Run the command and get the response and error returned
            process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            response, error = process.communicate()
            str.strip(error)

            if error:
                print("Error triggering expander reset: %s" % str(error))
                return process.returncode

            if response:
                print("Triggering expander reset: %s" % str(response))

        elif hasattr(args, 'fromstdin') and args.fromstdin:
            print("Ctrl-D stop reading from stdin and transmit.  Multiple msgs can be piped in.")
            json_txt = ""
            try:
                json_txt = sys.stdin.read()
            except KeyboardInterrupt:
                pass

            if not json_txt:
                return 0

            # Load in a multiple json msgs possibly sent in from stdin
            json_list = []
            decoder = JSONDecoder()
            s_len = len(json_txt)
            _w=BLANKSPACE.match

            end = 0
            while end != s_len:
                obj, end = decoder.raw_decode(json_txt, idx=_w(json_txt, end).end())
                end = _w(json_txt, end).end()
                json_list.append(obj)

            # Send them out one by one and wait for a valid response
            for json_msg in json_list:
                _send_raw_msg(json_msg, alldata=args.all, indent=args.human, remove_results_file=False)

        elif hasattr(args, 'fromfile') and args.fromfile:
            # Load in a multiple json msgs stored in a single file
            json_list = []
            json_txt = open(args.fromfile).read()
            decoder = JSONDecoder()
            s_len = len(json_txt)
            _w=BLANKSPACE.match

            end = 0
            while end != s_len:
                obj, end = decoder.raw_decode(json_txt, idx=_w(json_txt, end).end())
                end = _w(json_txt, end).end()
                json_list.append(obj)

            # Send them out one by one and wait for a valid response
            for json_msg in json_list:
                _send_raw_msg(json_msg, alldata=args.all, indent=args.human, remove_results_file=False)

        return 0
    except KeyboardInterrupt:
        return 0
    except Exception as e:
        print(("Exception trying to parse:{}".format(e)))
        indent = len(program_name) * " "
        sys.stderr.write(program_name + ": " + repr(e) + "\n")
        sys.stderr.write(indent + "  for help use --help")
        return 2

if __name__ == "__main__":
    sys.exit(main())
