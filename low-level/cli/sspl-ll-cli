#!/usr/bin/env python 
# encoding: utf-8
"""
 Filename:          sspl-ll-cli
 Description:       CLI to send msgs to SSPL-LL service
 Creation Date:     12/02/2015
 Author:            Jake Abernathy

 Do NOT modify or remove this copyright and confidentiality notice!
 Copyright (c) 2001 - $Date: 2015/01/14 $ Seagate Technology, LLC.
 The code contained herein is CONFIDENTIAL to Seagate Technology, LLC.
 Portions are also trade secret. Any use, duplication, derivation, distribution
 or disclosure of this code, for any reason, not expressly authorized is
 prohibited. All other rights are expressly reserved by Seagate Technology, LLC.
"""

import argparse 
import subprocess
import sys
import os
import re
import json
import time
from json import JSONDecoder
from pprint import pprint

# Add the top level directories
sys.path.insert(0, '/opt/seagate/sspl/low-level')
from framework.utils.config_reader import ConfigReader
from tests.manual.manual_test import ManualTest


__all__ = []
__version__ = 0.2
__date__ = '2015-12-02'
__updated__ = '2016-11-02'

FLAGS = re.VERBOSE | re.MULTILINE | re.DOTALL
WHITESPACE = re.compile(r'[ \t\n\r]*', FLAGS)

# Section containing information about the system we're running on
CONF_FILE_PATH  = '/etc/sspl_ll.conf'
SYS_INFORMATION = 'SYSTEM_INFORMATION'
CLI_TYPE        = 'cli_type'
SSPL_LL_SETTING = 'SSPL-LL_SETTING'
CORE_PROCESSORS = 'core_processors'
ACTUATORS       = 'actuators'
SENSORS         = 'sensors'


class CLIError(Exception):
    '''Generic exception to raise and log different fatal errors.'''
    def __init__(self, msg):
        super(CLIError).__init__(type(self))
        self.msg = "E: %s" % msg

    def __str__(self):
        return self.msg

    def __unicode__(self):
        return self.msg

def main():
    '''CLI to send msgs to SSPL-LL service'''

    # Display help if no args are passed in
    if len(sys.argv) == 1:
        sys.argv.append("--help")

    program_name = os.path.basename(sys.argv[0])
    program_version = "v%s" % __version__
    program_build_date = str(__updated__)
    program_version_message = '%%(prog)s %s (%s)' % (program_version, program_build_date)
    program_shortdesc = __import__('__main__').__doc__.split("\n")[1]
    description = "Program for interacting with SSPL-LL service"

    # Validate configuration file for required valid values
    try:
        conf_reader = ConfigReader(CONF_FILE_PATH)

    except (IOError, ConfigReader.Error) as err:
        # We don't have logger yet, need to find log_level from conf file first
        print "[ Error ] when validating the configuration file %s :" % \
            path_to_conf_file
        print err
        print "Exiting ..."
        sys.exit(os.EX_USAGE)

    # Read in CLI type value from configuration file
    cli_type = conf_reader._get_value_with_default(SYS_INFORMATION, 
                                                         CLI_TYPE,
                                                         'CS-A')
    global manTest
    if cli_type == "SED":
        # Setup argument parser
        parser = argparse.ArgumentParser(description=description, formatter_class=argparse.RawDescriptionHelpFormatter, \
                                         add_help=True)
        parser.add_argument("-v", "--version", action="version", version=program_version_message)
        try:
            # Create instance of ManualTest to publish messages
            manTest = ManualTest("PLANECNTRLRMQEGRESSPROCESSOR")
        except Exception:
            print("CLI only useful for verifying packages\n")
        _init_SED(parser, program_name)

    else:
        # Setup argument parser
        parser = argparse.ArgumentParser(description=description, formatter_class=argparse.RawDescriptionHelpFormatter, \
                                         add_help=False)
        parser.add_argument("-v", "--version", action="version", version=program_version_message)
        try:
            # Create instance of ManualTest to publish messages
            manTest = ManualTest("RABBITMQEGRESSPROCESSOR")
        except Exception:
            print("CLI only useful for verifying packages\n")
        _init_CS_A(parser, program_name)


def _send_raw_msg(jsonMsg, wait_for_response=True, response_wait_time=5,
                  alldata=False, indent=False, remove_results_file=True, 
                  host=None, force_wait=False):
    """Update authentication fields, validate and transmit json msg"""

    # Update the authentication fields in json msg
    manTest.addAuthFields(jsonMsg)

    # Validate the msg against the schemas
    manTest.validate(jsonMsg)

    # Encode and publish
    message = json.dumps(jsonMsg, ensure_ascii=True).encode('utf8')
    manTest.basicPublish(message=message, wait_for_response=wait_for_response, 
                         response_wait_time=response_wait_time, force_wait=force_wait,
                         alldata=alldata, indent=indent,
                         remove_results_file=remove_results_file,
                         exchange="sspl_halon_command", host=host)

def _send_iem_exchange(exchange, log_msg, host=None):
    """Sends an IEM on a particular rabbitmq exchange"""
    try:
        # Raw IEM sent as a string with no header authentication fields or schema validation
        manTest.basicPublish(message=log_msg, wait_for_response=False, 
                             exchange=exchange, host=host)
    except Exception as ae:
        print "IEM failed on exchange: {}".format(exchange)
        print "Exception:{}".format(ae)

def _send_SED_command(request, parameters, arguments, response_wait_time, force_wait):
    file = "/opt/seagate/sspl/low-level/tests/manual/actuator_msgs/plane_cntrl_request.json"
    jsonMsg = json.loads(open(file).read())
    jsonMsg["message"]["actuator_request_type"]["plane_controller"]["command"] = u"%s" % request
    jsonMsg["message"]["actuator_request_type"]["plane_controller"]["parameters"] = parameters
    jsonMsg["message"]["actuator_request_type"]["plane_controller"]["arguments"] = arguments

    _send_raw_msg(jsonMsg, response_wait_time=response_wait_time, indent=True, force_wait=force_wait)

def _sed_print_usage():
    print"Usage: sspl-ll-cli config [list | modify] key-management\n\t\t   drive [list | modify | erase | recover]"

def _config_parser(args):
    """Parse the initial config input"""
    #print"_config_parser args: %s" % str(args)
    if args.list == "None" or \
       args.modify == "None":
        _sed_print_usage()
        print"Choose from [list | modify] key-management\n"
        exit(0)

    return 'config %s %s %s %s %s %s' % (args.list, args.modify, \
                                        args.id, args.raid, args.node, args.debug)

def _drive_parser(args):
    """Parse the initial drive input"""
    #print"_drive_parser args: %s" % str(args)
    if args.list == "None" and \
       args.modify == "None" and \
       args.erase == "None" and \
       args.recover == "None":
        _sed_print_usage()
        print"Choose from [list | modify | erase | recover]\n"
        exit(0)

    return 'drive %s %s %s %s %s %s %s %s' % (args.list, args.modify, args.erase, args.recover, \
                                              args.id, args.raid, args.node, args.debug)

def _verify_parser(args):
    """Parse the initial verify input"""
    #print"_verify_parser args: %s" % str(args)
    if args.config is None:
        args.config = "/etc/sspl_ll.conf"
    if args.checkdeps == False:
        print"choose from [--checkdeps]"
        exit(0)

    return 'verify %s %s %s' % (args.checkdeps, args.config, args.autoinstall)

def _init_SED(parser, program_name):
    """Initialize options for Castor CS-A project"""
    # Entry point of SED key-management

    SED_subparser = parser.add_subparsers(title = 'Available Command Sets', description='SED Key Management')

    config_parser = SED_subparser.add_parser("config", add_help=True)
    config_parser.add_argument("list", nargs='?', type=str, default="None", help="list key-management")
    config_parser.add_argument("modify", nargs='?', type=str, default="None", help="modify key-management")
    config_parser.add_argument("-i", "--id", metavar="ID", help="Individual drive identifier, wwn or serial number")
    config_parser.add_argument("-r", "--raid", help="RAID group to apply operation")
    config_parser.add_argument("-n", "--node", help="System node to apply operation")
    config_parser.add_argument("-d", "--debug", metavar="ID", help="Show additional drive information, wwn or serial number")
    config_parser.set_defaults(func=_config_parser)

    drive_parser = SED_subparser.add_parser("drive", add_help=True)
    drive_parser.add_argument("list", nargs='?', type=str, default="None", help="list key-management")
    drive_parser.add_argument("modify", nargs='?', type=str, default="None", help="modify key-management")
    drive_parser.add_argument("erase", nargs='?', type=str, default="None", help="erase key-management")
    drive_parser.add_argument("recover", nargs='?', type=str, default="None", help="recover key-management")
    drive_parser.add_argument("-i", "--id", metavar="ID", help="Individual drive identifier, wwn or serial number")
    drive_parser.add_argument("-r", "--raid", help="RAID group to apply operation")
    drive_parser.add_argument("-n", "--node", help="System node to apply operation")
    drive_parser.add_argument("-d", "--debug", metavar="ID", help="Show additional drive information, wwn or serial number")
    drive_parser.set_defaults(func=_drive_parser)

    verify_parser = SED_subparser.add_parser("verify", add_help=True)
    verify_parser.add_argument("--checkdeps", action="store_true", help="Verify that dependencies are installed")
    verify_parser.add_argument("-c", "--config", metavar="FILE", help="Configuration file, defaults to /etc/sspl_ll.conf")
    verify_parser.add_argument("-a", "--autoinstall", action="store_true", help="Automatically attempt to install required packages")
    verify_parser.set_defaults(func=_verify_parser)

    try:
        # Process arguments
        args = parser.parse_args()
        values = args.func(args).split()

        if "help" in values:
            parser.print_help()
            return 1

        # Branch off and handle config or drive commands
        if values[0] == "config":
            success, request, parameters, arguments, response_wait_time, force_wait = _process_SED_config(values[1:])
        elif values[0] == "drive":
            success, request, parameters, arguments, response_wait_time, force_wait = _process_SED_drive(values[1:])
        elif values[0] == "verify":
            # See if --checkdeps is set and verify packages are installed
            if values[1] == "True":
                check_dependencies(values[2], values[3])
            return

        # If successful then send the msg
        if success:
            if request:
                _send_SED_command(request, parameters, arguments, response_wait_time, force_wait)
        else:
            if request == "cancel":
                print"Operation cancelled"
            else:
                print"A problem occurred, try again."

    except KeyboardInterrupt:
        print"\nHalting sspl-ll-cli\n"
        return 0       
    except Exception as e:
        print"An error occurred: %s" % str(e)
        _sed_print_usage()

def _get_sed_input(command, available_commands, get_value, verify_value, value_list):
    """Prompt the user for a value for an item listed in available_commands"""
    input = "N/A"
    value = "N/A"

    while len(input) == 0 or \
        input not in available_commands:
        input = raw_input("%s: \n\t%s\nsspl-ll-cli> " % (command, available_commands)).strip()

    if input == "cancel":
        return input, None

    command_list = available_commands.replace("{","").replace("}","").replace(" ", "").split(",")
    command_index = command_list.index(input)

    # Get a value for the selected input and verify it's in the value_list
    if get_value:
        valid_values = value_list[command_index]
        value = raw_input("Set '%s' to [%s]: " % (input, valid_values))
        if verify_value:
            while len(value) == 0 or \
                    (value not in valid_values and \
                       "Any" not in valid_values):
                value = raw_input("Available choices: \n\t[%s]\nsspl-ll-cli> " % valid_values).strip()
    return input, value

def _process_SED_drive(values):
    """Process values from command line for drive requests"""
    try:
        #print "drive values: %s" % values
        for idx, value in enumerate(values):
            if values[idx]== "None":
                values[idx] = None
        params = {'drive_id':values[4], 'raid_id': values[5], 'node_id':values[6], 'debug_id': values[7]}
        arguments = {}

        # If we're sending request to all nodes then force a 7 second delay and then read from rabbitmq
        if values[6] == "None":
            force_wait = True
            response_timeout = 45
        else:
            force_wait = False
            response_timeout = 30

        # Drive list key-management
        if values[0] == "list":
            # Only care about arguments to identify the scope of the request, todo make these configurable via cli
            arguments = {'condition': None, 'fromdb': None, 'ignoreha': False}
            request = "status"

        elif values[0] == "modify":
            input, value = _get_sed_input("Available drive-level settings", "{security}", \
                                           True, True, ["key-rotate, unlock"])
            if input == "security":
                if value == "key-rotate":
                    request = "%s %s %s" % (values[0], input, value)

                elif value == "unlock":
                    request = "%s %s %s" % (values[0], input, value)

        elif values[0] == "erase":
            # Only care about paramaters to identify the scope of the request
            request = "%s" % values[0]

            # Verify that the user really wants to erase
            response = raw_input("Drive erase confirm: \n\t[yes, no]\nsspl-ll-cli> ").strip()
            if response == "yes":
                arguments = {"recovery": None}
            else:
                return False, "cancel", None, None

        elif values[0] == "recover":
            # Only care about paramaters to identify the scope of the request
            request = "%s" % values[0]

        return True, request, params, arguments, response_timeout, force_wait

    except Exception as e:
        print"_process_SED_drive, Error occurred: %s" % str(e)

def _process_SED_config(values):
    """Process values from command line for config requests
     @return: success, request, parameters, response_wait_time"""
    try:
        #print "config values: %s" % values
        params = {'drive_id':values[2], 'raid_id': values[3], 'node_id':values[4], 'debug_id': values[5]}

        # If we're sending request to all nodes then force a 7 second delay and then read from rabbitmq
        if values[4] == "None":
            force_wait = True
            response_timeout = 45
        else:
            force_wait = False
            response_timeout = 30

        # Config list key-management
        if values[0] == "list":
            if values[1] == "key-management":
                return True, "list system-level key-management", params, response_timeout, force_wait

        # Config modify key-management
        elif values[0] == "modify":
            if values[1] == "key-management":
                input, value = _get_sed_input("Available system-level settings", "{kind, server, recovery, fips}", \
                                               True, True, ["off | ko | kmpi | local", "Any URI", \
                                                            "on | off | password", "on | off"])                
                # If input is 'recovery' then get passwords
                if input == "recovery":
                    if value == "on" or \
                        value == "password":

                        display_pass = "new-password"
                        if value == "password":
                            display_pass = "old-password"

                        on_input1, pass1 = _get_sed_input("Select 'recovery' %s option" % value, "{%s, cancel}" % display_pass, \
                                                    True, True, ["Any alpha-numeric string"])
                        if on_input1 == "cancel":
                            return False, "cancel", params, None, None

                        if value == "on":
                            display_pass = "repeat-password"
                        else:
                            display_pass = "new-password"
                        if on_input1:
                            on_input2, pass2 = _get_sed_input("Select 'recovery' %s option" % value, "{%s, cancel}" % display_pass, \
                                                              True, True, ["Any alpha-numeric string"])
                        if not on_input1 or \
                            not on_input2:
                            return False, None, None, None, None
                        # Make sure the passwords match
                        if value == "on" and \
                            pass1 != pass2:
                            print "Error passwords do not match"
                            return False, None, None, None, None

                        if on_input2 == "cancel":
                            return False, "cancel", None, None, None

                        # Put together the request with passwords
                        if value == "password":
                            request = "%s %s %s %s %s %s" % (values[0], values[1], input, value, pass1, pass2)
                        else: 
                            request = "%s %s %s %s %s" % (values[0], values[1], input, value, pass1)
                    else:
                        request = "%s %s %s %s off" % (values[0], values[1], input, value)

                # Put together the request
                else:
                    request = "%s %s %s %s" % (values[0], values[1], input, value)

                return True, request, params, response_timeout, force_wait

    except Exception as e:
        print"_process_SED_config, Error occurred: %s" % str(e)
    return False, None, None, None, None

def _init_CS_A(parser, program_name):
    """Initialize options for Castor CS-A project"""
    parser.add_argument("--help", action="store_true", help="display this help message and exit")
    parser.add_argument("-a", "--all", action="store_true", help="display all the data received in responses")
    parser.add_argument("-h", "--human", action="store_true", help="display responses with indentation for readability")
    parser.add_argument("--generic", metavar="COMMAND", help="execute from command line ie 'SWAP ON'")
    parser.add_argument("--pdu", metavar="COMMAND", help="send command to PDU. \
                          ie 'show outlets details'")
    parser.add_argument("--restartthread", metavar="NAME", help="restart an internal thread within the service")
    parser.add_argument("--servicename", metavar="NAME", help="name of service to apply request")
    parser.add_argument("--servicereq", metavar="REQUEST", help="start/stop/restart/status/enable/disable request")
    parser.add_argument("--ipmicmd", metavar="COMMAND", help="on/off/cycle/status (chassis power cmds or status)")
    parser.add_argument("--ipmiIP", metavar="IP", help="IP to apply command")
    parser.add_argument("--hdparm", metavar="COMMAND", help="ie \"-I /dev/sda | grep 'Serial Number:'\"")
    parser.add_argument("--iemlog", metavar="MESSAGE", help="IEM log.  ie 'IEC: 001002001: Rules Engine...'")
    parser.add_argument("--iemloglevel", metavar="LEVEL", help="IEM log level.  ie LOG_CRIT, LOG_ERR, LOG_WARNING")
    parser.add_argument("--iemhost", metavar="HOST", help="IEM receiver. ie 10.22.192.100, default localhost")
    parser.add_argument("--iemexchange", metavar="EXCHNG", help="RabbitMQ exchange. ie sspl_iem, default sspl_halon")
    parser.add_argument("--fsstats", metavar="FSFIDKEY", help="display total/free space on Mero, ie --fsstats 4")

    group = parser.add_mutually_exclusive_group()
    group.add_argument("--smrdata", action="store_true", help="log SMR drive register data")
    group.add_argument("--cpudata", action="store_true", help="display CPU data")
    group.add_argument("--hostdata", action="store_true", help="display host data")
    group.add_argument("--mountdata", action="store_true", help="display local mount data")
    group.add_argument("--interfacedata", action="store_true", help="display network interface data")
    group.add_argument("--raiddata", action="store_true", help="display RAID data")

    parser.add_argument("--fromstdin", action="store_true", help="read JSON msg(s) from stdin")
    parser.add_argument("--fromfile", metavar="FILE", help="read JSON msg(s) from file")

    parser.add_argument("--stopdrive", metavar="DRIVE", help="power down a drive.  ie /dev/sda1")
    parser.add_argument("--startdrive", metavar="DRIVE", help="power up a drive.  ie /dev/sda1")
    parser.add_argument("--resetdrive", metavar="DRIVE", help="reset drive by cycling its power.  ie /dev/sda1")
    parser.add_argument("--smart", metavar="DRIVE", help="schedule a SMART test on a drive. ie /dev/sda1 or '*'")
    parser.add_argument("--drvmngr", metavar="DRIVE", help="display drivemanager's status. ie /dev/sda1 or '*'")
    parser.add_argument("--hpi", metavar="DRIVE", help="display HPI status. ie /dev/sda1 or '*'")
    parser.add_argument("--setdrivestatus", metavar="DRIVE --status [STATUS] --reason [REASON]",
                        help="set status and reason of a drive. ie /dev/sda1 or " \
                        "s/n, --status STATUS --reason REASON")
    parser.add_argument("--status", metavar="STATUS", help="set the status field used in --setdrivestatus")
    parser.add_argument("--reason", metavar="REASON", help="set the reason field used in --setdrivestatus")

    parser.add_argument("--setdriveLED", metavar="DRIVE --LEDstate [LEDSTATE]",
                        help="set LED state of a drive. ie /dev/sda1 or " \
                        "s/n, --LEDstate LEDSTATE")
    parser.add_argument("--getdriveLED", metavar="DRIVE",
                        help="get LED state of a drive. ie /dev/sda1 or s/n")
    parser.add_argument("--LEDstate", metavar="LEDSTATE", help="FAULT_ON, FAULT_OFF, IDENTIFY_ON, IDENTIFY_OFF,"\
                        "PULSE_SLOW_ON, PULSE_SLOW_OFF, PULSE_FAST_ON, PULSE_FAST_OFF")
    group.add_argument("--expreset", action="store_true", help="trigger expander reset")
    parser.add_argument("--simulate", metavar="IDENTIFIER --event [EVENT]",
                        help="simulate an event. ie /dev/sda1 or s/n " \
                        "--event EVENT")
    parser.add_argument("--event", metavar="EVENT", help="DRIVE_INSTALL, DRIVE_UNINSTALL, EXP_RESET, SMART_FAILURE." \
                        "  ie --simulate all-drives --event EXP_RESET")
    parser.add_argument("--checkdeps", action="store_true", help="Verify package dependencies required for configuration." \
                        "  ie --checkdeps --config=CONFIG --autoinstall")
    parser.add_argument("--config", metavar="CONFIG", help="Configuration file used to check dependencies.")
    parser.add_argument("--autoinstall", action="store_true", help="Automatically attempt to install required packages.")

    try:
        # Process arguments
        args = parser.parse_args()

        if args.help:
            parser.print_help()

        elif args.pdu:
            # Load a PDU message from the manual tests directory and update it with args.pdu
            file = "/opt/seagate/sspl/low-level/tests/manual/actuator_msgs/node_cntrl_pdu.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["node_controller"]["node_request"] = u"PDU: {}".format(args.pdu)
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human, force_wait=True, response_wait_time=30)

        elif args.generic:
            # Load a generic SSPL message from the manual tests directory and update it with args.generic
            file = "/opt/seagate/sspl/low-level/tests/manual/actuator_msgs/node_cntrl_sspl.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["node_controller"]["node_request"] = u"SSPL: {}".format(args.generic)
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human, response_wait_time=60)

        elif args.stopdrive:
            # Load a stop drive message from the manual tests directory and update it with args.stopdrive
            file = "/opt/seagate/sspl/low-level/tests/manual/actuator_msgs/node_cntrl_stop_drive.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["node_controller"]["node_request"] = u"STOP_DRIVE: {}".format(args.stopdrive)
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human, response_wait_time=60)

        elif args.startdrive:
            # Load a start drive message from the manual tests directory and update it with args.startdrive
            file = "/opt/seagate/sspl/low-level/tests/manual/actuator_msgs/node_cntrl_start_drive.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["node_controller"]["node_request"] = u"START_DRIVE: {}".format(args.startdrive)
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human, response_wait_time=60)

        elif args.resetdrive:
            # Load a reset drive message from the manual tests directory and update it with args.resetdrive
            file = "/opt/seagate/sspl/low-level/tests/manual/actuator_msgs/node_cntrl_reset_drive.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["node_controller"]["node_request"] = u"RESET_DRIVE: {}".format(args.resetdrive)
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human, response_wait_time=60)

        elif args.smart:
            # Load a smart test message from the manual tests directory and update it with args.smart
            file = "/opt/seagate/sspl/low-level/tests/manual/actuator_msgs/node_cntrl_smart_test.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["node_controller"]["node_request"] = u"SMART_TEST: {}".format(args.smart)

            print("\nInitiating SMART tests.  This can take several minutes...\n")
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human, response_wait_time=300,
                          force_wait=True)

        elif args.drvmngr:
            # Load a drivemanager status message from the manual tests directory and update it with args.drvmngr
            file = "/opt/seagate/sspl/low-level/tests/manual/actuator_msgs/node_cntrl_drvmngr_status.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["node_controller"]["node_request"] = u"DRVMNGR_STATUS: {}".format(args.drvmngr)

            force_wait = False
            wait_time = 3
            if "*" in str(args.drvmngr):
                wait_time = 30
                force_wait = True

            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human, response_wait_time=wait_time,
                          force_wait=force_wait)

        elif args.hpi:
            # Load a reset hpi status message from the manual tests directory and update it with args.hpi
            file = "/opt/seagate/sspl/low-level/tests/manual/actuator_msgs/node_cntrl_hpi_status.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["node_controller"]["node_request"] = u"HPI_STATUS: {}".format(args.hpi)

            force_wait = False
            wait_time = 3
            if "*" in str(args.hpi):
                wait_time = 30
                force_wait = True

            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human, response_wait_time=wait_time,
                          force_wait=force_wait)

        elif args.getdriveLED:
            # Load a node controller LED message from the manual tests directory and update it with args.getdriveLED
            file = "/opt/seagate/sspl/low-level/tests/manual/actuator_msgs/node_cntrl_LED.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["node_controller"]["node_request"] = u"LED: get {}".format(args.getdriveLED)

            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human, response_wait_time=5)

        elif args.setdriveLED:
            # Load a node controller LED message from the manual tests directory and update it with args 
            if not args.LEDstate:
                print("Error: must provide a LED state --LEDstate LEDSTATE when using --setdriveLED")
                return

            if args.LEDstate not in ["FAULT_ON", "FAULT_OFF", "IDENTIFY_ON", 
                                     "IDENTIFY_OFF", "PULSE_SLOW_ON", "PULSE_SLOW_OFF", 
                                     "PULSE_FAST_ON", "PULSE_FAST_OFF"]:
                print("Possible LED states: FAULT_ON, FAULT_OFF, IDENTIFY_ON, IDENTIFY_OFF," \
                      "PULSE_SLOW_ON, PULSE_SLOW_OFF, PULSE_FAST_ON, PULSE_FAST_OFF")
                return

            file = "/opt/seagate/sspl/low-level/tests/manual/actuator_msgs/node_cntrl_LED.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["node_controller"]["node_request"] = u"LED: set {} {}" \
                        .format(args.setdriveLED, args.LEDstate)

            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human, response_wait_time=5)

        elif args.simulate:
            # Load a node controller SIM message from the manual tests directory and update it with args 
            if not args.event:
                print("Error: must provide an event to simulate --event EVENT when using --simulate")
                return

            if args.event not in ["DRIVE_INSTALL", "DRIVE_UNINSTALL", "EXP_RESET", "SMART_FAILURE"]:
                print("Possible simulated EVENTS: DRIVE_INSTALL, DRIVE_UNINSTALL, EXP_RESET, SMART_FAILURE")
                return

            file = "/opt/seagate/sspl/low-level/tests/manual/actuator_msgs/node_cntrl_simulate_drive.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["node_controller"]["node_request"] = u"SIMULATE: {} {}" \
                        .format(args.event, args.simulate)

            # Don't wait for a response if requesting SMART failure as it just sets a flag in SSPL
            if args.event == "SMART_FAILURE":
                print("\nSMART failure flagged which will affect the next request sent to run a SMART test.\n")
                _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human, wait_for_response=False)
            else:
                _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human, response_wait_time=30)

        elif args.setdrivestatus:
            # Load a HDS logging message from the manual tests directory and update it with args 
            if not args.status:
                print("Error: must provide a status --status STATUS when using --setdrivestatus")
                return

            if not args.reason:
                print("Error: must provide a reason --reason REASON when using --setdrivestatus")
                return

            drive = str(args.setdrivestatus)
            status = str(args.status)
            reason = str(args.reason)

            if drive.startswith("/"):
                print("Retrieving serial number using device name with hdparm tool")
                # Build the desired command using hdparm tool
                command = "/usr/sbin/hdparm -I {} | grep 'Serial Number:'".format(drive)
                print("executing command: %s" % command)

                # Run the command and get the response and error returned
                process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                hdparm_response, error = process.communicate()

                # If an error exists stop here and return the response
                if error:
                    drive = "FAKE_TEST_SN"
                    print("Failed to lookup s/n: {}".format(error))
                    print("Ignoring and using a test s/n: %s" % drive)
                else:
                    # Parse out "Serial Number:" from hdparm result to obtain serial number
                    drive = hdparm_response[15:].strip()
                    print("Successfully retrieved s/n: %s" % drive)

            log_msg = "IEC: 038001001: Halon Disk Status: {'status': '%s', 'reason': '%s'," \
                        "'serial_number': '%s'}" % (status, reason, drive)
            print("log_msg: %s" % log_msg)

            file = "/opt/seagate/sspl/low-level/tests/manual/actuator_msgs/HDS_logging.json"
            jsonMsg = json.loads(open(file).read())

            print("    log_msg: %s" % log_msg)
            jsonMsg["message"]["actuator_request_type"]["logging"]["log_msg"] = u"{}".format(log_msg)
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human)

        elif args.restartthread:
            # Load a restart thread message from the manual tests directory and update it with args.restartthread
            file = "/opt/seagate/sspl/low-level/tests/manual/actuator_msgs/thread_cntrl_restart.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["thread_controller"]["module_name"] = u"{}".format(args.restartthread)
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human)

        elif args.servicename or args.servicereq:
            if not args.servicename:
                print("Error: must provide a service name to apply request using --servicename NAME")
                return

            if not args.servicereq:
                print("Error: must provide a request to apply to the service using --servicereq REQUEST")
                print("       where REQUEST must be one of: start/stop/restart/status/enable/disable")
                return

            if args.servicereq not in ['start', 'stop', 'restart', 'status', 'enable', 'disable']:
                print("Error: Service request must be one of: start/stop/restart/status/enable/disable")
                return

            if ".service" not in args.servicename:
                args.servicename += ".service"

            # Load a service controller message from the manual tests directory and update it with args.servicename & servicereq
            file = "/opt/seagate/sspl/low-level/tests/manual/actuator_msgs/service_cntrl_restart.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["service_controller"]["service_name"] = u"{}".format(args.servicename)
            jsonMsg["message"]["actuator_request_type"]["service_controller"]["service_request"] = u"{}".format(args.servicereq)
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human)

        elif args.ipmicmd or args.ipmiIP:
            if not args.ipmiIP:
                print("Error: must provide an IP to apply using --ipmiIP IP")
                return

            if args.ipmicmd not in ['on', 'off', 'cycle', 'status']:
                print("Error: IPMI command must be one of: on/off/cycle/status")
                return

            # Load a IPMI command message from the manual tests directory and update it with args.ipmicmd & ipmiIP
            file = "/opt/seagate/sspl/low-level/tests/manual/actuator_msgs/node_cntrl_ipmi_status.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["node_controller"]["node_request"] = u"IPMI: {} {}". \
                                    format(args.ipmiIP, args.ipmicmd)
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human)

        elif args.hdparm:
            # Load a hdparm message from the manual tests directory and update it with args.hdparm
            file = "/opt/seagate/sspl/low-level/tests/manual/actuator_msgs/node_cntrl_hdparm.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["node_controller"]["node_request"] = u"HDPARM: {}".\
                                    format(args.hdparm)
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human)

        elif args.iemlog or args.iemloglevel:
            if not args.iemlog:
                print("Error: must provide an IEM message using --iemlog MESSAGE")
                return
 
            if not args.iemloglevel:
                print("Error: must provide a log level to apply using --iemloglevel LEVEL")
                print("       where LEVEL is one of: LOG_EMERG, LOG_ALERT, LOG_CRIT, LOG_ERR,") 
                print("                              LOG_WARNING, LOG_NOTICE, LOG_INFO, LOG_DEBUG")
                return

            if args.iemloglevel not in ['LOG_EMERG', 'LOG_ALERT', 'LOG_CRIT', 'LOG_ERR', \
                                        'LOG_WARNING', 'LOG_NOTICE', 'LOG_INFO', 'LOG_DEBUG']:
                print("Error: IEM log level must be one of: LOG_EMERG, LOG_ALERT, LOG_CRIT, LOG_ERR, ")
                print("                                  LOG_WARNING, LOG_NOTICE, LOG_INFO, LOG_DEBUG")
                return

            if "IEC" not in args.iemlog:
                print("Error: IEM log must be in form: 'IEC: xxxxxxxx: {JSON data}")
                return

            # Default to standard json format with typical headers
            if not args.iemexchange:
                # Load a logging message from the manual tests directory and update it with args.iemlog
                file = "/opt/seagate/sspl/low-level/tests/manual/actuator_msgs/logging.json"
                jsonMsg = json.loads(open(file).read())
                jsonMsg["message"]["actuator_request_type"]["logging"]["log_level"] = u"{}".\
                                                            format(args.iemloglevel)
                jsonMsg["message"]["actuator_request_type"]["logging"]["log_msg"] = u"{}".\
                                                            format(args.iemlog)
                _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human, 
                              wait_for_response=False, host=args.iemhost)
            else:
                log_msg = "{} {}".format(args.iemloglevel, args.iemlog)
                _send_iem_exchange(args.iemexchange, log_msg, host=args.iemhost)

        elif args.smrdata:
            # Load a restart thread message from the manual tests directory and update it with SMRdriveData
            file = "/opt/seagate/sspl/low-level/tests/manual/actuator_msgs/thread_cntrl_restart.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["thread_controller"]["module_name"] = u"SMRdriveData"
            _send_raw_msg(jsonMsg, wait_for_response=False, alldata=args.all, indent=args.human)
            print("Check logs for new SMR drive register values")

        elif args.fsstats:
            # Load a node controller mero message and update it
            file = "/opt/seagate/sspl/low-level/tests/manual/actuator_msgs/node_cntrl_mero.json"
            jsonMsg = json.loads(open(file).read())
            jsonMsg["message"]["actuator_request_type"]["node_controller"]["node_request"] = \
                    u"MERO: fsstats {}".format(args.fsstats)
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human, response_wait_time=30)

        elif args.cpudata:
            # Load a sensor request message for cpu data from the manual tests directory and send it in
            file = "/opt/seagate/sspl/low-level/tests/manual/actuator_msgs/sensor_request_cpu_data.json"
            jsonMsg = json.loads(open(file).read())
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human)

        elif args.hostdata:
            # Load a sensor request message for host data from the manual tests directory and send it in
            file = "/opt/seagate/sspl/low-level/tests/manual/actuator_msgs/sensor_request_host_update.json"
            jsonMsg = json.loads(open(file).read())
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human)

        elif args.mountdata:
            # Load a sensor request message for local mount data from the manual tests directory and send it in
            file = "/opt/seagate/sspl/low-level/tests/manual/actuator_msgs/sensor_request_mount_data.json"
            jsonMsg = json.loads(open(file).read())
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human)

        elif args.interfacedata:
            # Load a sensor request message for network data from the manual tests directory and send it in
            file = "/opt/seagate/sspl/low-level/tests/manual/actuator_msgs/sensor_request_if_data.json"
            jsonMsg = json.loads(open(file).read())
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human)

        elif args.raiddata:
            # Load a sensor request message for raid data from the manual tests directory and send it in
            file = "/opt/seagate/sspl/low-level/tests/manual/actuator_msgs/sensor_request_raid_data.json"
            jsonMsg = json.loads(open(file).read())
            _send_raw_msg(jsonMsg, alldata=args.all, indent=args.human)

        elif args.expreset:
            # Trigger expander reset

            # Get the SG device
            command = "ls /sys/class/enclosure/*/device/scsi_generic"

            # Run the command and get the response and error returned
            process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            response, error = process.communicate()

            sg_dev = "/dev/{}".format(response.rstrip('\n'))
            command = "wbcli {} reboot".format(sg_dev)

            # Run the command and get the response and error returned
            process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            response, error = process.communicate()
            if error:
                print("Error triggering expander reset: %s" % str(error))
            if response:
                print("Triggering expander reset: %s" % str(response))

        elif args.fromstdin:
            print("Ctrl-D stop reading from stdin and transmit.  Multiple msgs can be piped in.")
            json_txt = ""
            try:
                json_txt = sys.stdin.read()
            except KeyboardInterrupt:
                pass

            if not json_txt:
                return 0

            # Load in a multiple json msgs possibly sent in from stdin
            json_list = []
            decoder = JSONDecoder()
            s_len = len(json_txt)
            _w=WHITESPACE.match

            end = 0
            while end != s_len:
                obj, end = decoder.raw_decode(json_txt, idx=_w(json_txt, end).end())
                end = _w(json_txt, end).end()
                json_list.append(obj)

            # Send them out one by one and wait for a valid response
            for json_msg in json_list:
                _send_raw_msg(json_msg, alldata=args.all, indent=args.human, remove_results_file=False)

        elif args.fromfile:
            # Load in a multiple json msgs stored in a single file
            json_list = []
            json_txt = open(args.fromfile).read()
            decoder = JSONDecoder()
            s_len = len(json_txt)
            _w=WHITESPACE.match

            end = 0
            while end != s_len:
                obj, end = decoder.raw_decode(json_txt, idx=_w(json_txt, end).end())
                end = _w(json_txt, end).end()
                json_list.append(obj)

            # Send them out one by one and wait for a valid response
            for json_msg in json_list:
                _send_raw_msg(json_msg, alldata=args.all, indent=args.human, remove_results_file=False)

        elif args.checkdeps:
            config_file = "/etc/sspl_ll.conf"
            if args.config:
                config_file = args.config

            auto_install = False
            if args.autoinstall:
                auto_install = True

            check_dependencies(config_file, auto_install)

        return 0
    except KeyboardInterrupt:
        return 0
    except Exception, e:
        print("Exception trying to parse:{}".format(e))
        indent = len(program_name) * " "
        sys.stderr.write(program_name + ": " + repr(e) + "\n")
        sys.stderr.write(indent + "  for help use --help")
        return 2

def check_dependencies(config_file, auto_install):
    """Loop throught the configuration file and verify the required packages are installed"""
    print("Checking dependencies required for configuration file: %s" % config_file)

    try:
        conf_reader = ConfigReader(config_file)
    except (IOError, ConfigReader.Error) as err:
        # We don't have logger yet, need to find log_level from conf file first
        print "[ Error ] when validating the configuration file %s :" % \
            path_to_conf_file
        print err
        print "Exiting ..."
        sys.exit(os.EX_USAGE)

    # Read in the core processors, actuators & sensor modules
    modules = conf_reader._get_value_list(SSPL_LL_SETTING, CORE_PROCESSORS)
    modules += conf_reader._get_value_list(SSPL_LL_SETTING, ACTUATORS)
    modules += conf_reader._get_value_list(SSPL_LL_SETTING, SENSORS)
    print("Current SSPL-LL configuraiton using modules: %s\n" % modules)

    # Read in the files/sspl_ll_deps.json that lists the dependencies for each module
    with open("/opt/seagate/sspl/low-level/files/sspl_ll_deps.json") as data_file:
        deps_json = json.load(data_file)

    # Loop thru all the modules and get their dependencies
    for module in modules:
        deps = deps_json.get(module)
        if deps is not None:
            dep_map = dict(deps)
            print("\nProcessing %s:" % module)
            for dep, version in dep_map.iteritems():
                # Get the version of the package installed
                command = "rpm -q --qf '%%{VERSION}' %s" % dep
                process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                response, error = process.communicate()
                missing = False
                if error is not None and \
                   len(error) > 0:
                    print("\tPackage: %s, minimum required: %s FAILED!\n\n" % (dep, version))
                    print("\tPackage: %s Error: %s" % (dep, error))
                    if str(auto_install) == "True":
                        install_package(dep)

                elif "not installed" in response:
                    print("\n\tPackage %s is not installed"% dep)
                    if str(auto_install) == "True":
                        install_package(dep)

                else:
                    required_version = version.replace(".", "")
                    installed_version = response.replace(".", "")

                    # If the versions are digits then compare
                    if required_version.isdigit() and \
                        installed_version.isdigit():
                        if int(installed_version) < int(required_version):
                            print("\tPackage: %s, minimum required: %s, installed: %s FAILED!" % (dep, version, response))
                            if str(auto_install) == "True":
                                install_package(dep)
                        else:
                            print("\tPackage: %s, minimum required: %s, installed: %s OK!" % (dep, version, response))
                    else:
                        print("\tPackage: %s, minimum required: %s, installed: %s OK!" % (dep, version, response))

def install_package(dep):
    """Use yum to install a package"""
    print("\tAttempting to install/update: %s" % dep)
    try:
        command = "yum -y --nogpgcheck install %s" % dep
        process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        response, error = process.communicate()
        if error is not None and \
            len(error) > 0:
            print("\tFailed installing package, %s" % error)
        else:
            print("Result: %s" % response)
    except Exception as ae:
        print("sspl-ll-cli install package: %s" % str(ae))


if __name__ == "__main__":
    sys.exit(main())
