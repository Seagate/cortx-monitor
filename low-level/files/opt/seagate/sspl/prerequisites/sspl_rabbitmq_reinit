#!/usr/bin/python3.6

# Copyright (c) 2020 Seagate Technology LLC and/or its Affiliates
#
# This program is free software: you can redistribute it and/or modify it under the
# terms of the GNU Affero General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
# PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License along
# with this program. If not, see <https://www.gnu.org/licenses/>. For any questions
# about this software or licensing, please email opensource@seagate.com or
# cortx-questions@seagate.com.


"""
 *************************************************************
  Description:   Rabbitmq setup script
  Purpose    :   Creates rmq user and queues using SSPL config
  Usage      :   ./sspl_rabbitmq_reinit
 *************************************************************
"""

import os
import subprocess
import sys
import socket
import pika
import consul

from cortx.utils.security.cipher import Cipher, CipherInvalidToken

# Required sections
RABBITMQCTL = '/usr/sbin/rabbitmqctl'
SECTION="RABBITMQEGRESSPROCESSOR"
INGRESS_CONFIG_SECTION = 'RABBITMQINGRESSPROCESSOR'
EGRESS_CONFIG_SECTION = 'RABBITMQEGRESSPROCESSOR'
LOGGER_CONFIG_SECTION = 'LOGGINGPROCESSOR'
CLUSTER_SECTION = 'RABBITMQCLUSTER'
SYSTEM_INFORMATION = 'system_information'
ERLANG_COOKIE_PATH = '/var/lib/rabbitmq/.erlang.cookie'

# Required keys
EXCHANGE_NAME_KEY = 'exchange_name'
QUEUE_NAME_KEY = 'queue_name'
ROUTING_KEY = 'routing_key'
VIRT_HOST_KEY = 'virtual_host'
RPMQ_USERNAME_KEY = 'username'
RPMQ_PASSWORD_KEY = 'password'
CLUSTER_ID_KEY = 'cluster_id'

# Establish consul connection
CONSUL_HOST = '127.0.0.1'
CONSUL_PORT = '8500'
consul_conn = consul.Consul(host=CONSUL_HOST, port=CONSUL_PORT)


def get_sspl_config_value(key, sect="", prefix="sspl/config", default=None):
    v = None
    if sect:
        k = prefix + "/" + sect + "/" + key
    else:
        k = prefix + '/' + key
    res = consul_conn.kv.get(k)[1]
    if res and res['Value']:
        v = res['Value'].decode()
        if "," in v:
            v = v.replace(" ", "").split(",")
    if not v:
        v = default
    return v

def get_common_config_value(key, sect="", default=None):
    v = None
    if sect:
        k = sect + "/" + key
    res = consul_conn.kv.get(k)[1]
    if res and res['Value']:
        v = res['Value'].decode()
        if "," in v:
            v = v.replace(" ", "").split(",")
    if not v:
        v = default
    return v

def _gen_key(cluster_id, service_name):
    # Generate key for decryption
    key = Cipher.generate_key(cluster_id, service_name)
    return key

def _decrypt(key, text):
    '''Decrypt the <text>'''
    decrypt_text = text
    try:
        decrypt_text = Cipher.decrypt(key, text).decode()
        return decrypt_text
    except CipherInvalidToken as e:
        print("ERROR: Password decryption failed requested by %s" % SECTION)
        return decrypt_text.decode()

def main():
    """ Main method of this program. """

    _check_and_reset_rabbitmq()
    _start_rabbitmq()

    virtual_host = get_sspl_config_value(key=VIRT_HOST_KEY, sect=SECTION, default='SSPL')
    username = get_sspl_config_value(key=RPMQ_USERNAME_KEY, sect=SECTION, default='sspluser')
    password = get_sspl_config_value(key=RPMQ_PASSWORD_KEY, sect=SECTION, default='sspl4ever')

    _create_vhost_if_necessary(virtual_host)

    # Decrypt password
    cluster_id = get_common_config_value(key=CLUSTER_ID_KEY, sect=SYSTEM_INFORMATION)
    key = _gen_key(cluster_id, 'rabbitmq')
    password = _decrypt(key, password.encode('ascii'))
    _create_user_if_necessary(username, password, virtual_host)

    # create durable/mirrored queues in either single or clustered mode.
    create_mirrored_queues(key)
    _set_perms_erlang_key()

def sync_queue(queue_name):
    """Queues need to be synced when new node joined to the cluster.
    """
    command = f'{RABBITMQCTL} sync_queue -p SSPL {queue_name}'
    _send_command(command)

def create_mirrored_queues(decryption_key):
    print('INFO: Creating mirrored queues...')
    # creating actuator-req-queue queue.
    vhost, username, password, exchange_name, queue_name, routing_key = \
        _get_connection_config(INGRESS_CONFIG_SECTION)
    _set_ha_policy(queue_name)
    create_queue(vhost, username, _decrypt(decryption_key, password.encode('ascii')),
                exchange_name, queue_name, routing_key)
    sync_queue(queue_name)

    # creating sensor-queue queue
    vhost, username, password, exchange_name, queue_name, routing_key = \
        _get_connection_config(EGRESS_CONFIG_SECTION)
    _set_ha_policy(queue_name)
    create_queue(vhost, username, _decrypt(decryption_key, password.encode('ascii')), exchange_name,
                 queue_name, routing_key)
    sync_queue(queue_name)

    # creating iem-queue queue
    vhost, username, password, exchange_name, queue_name, routing_key = \
        _get_connection_config(LOGGER_CONFIG_SECTION)
    _set_ha_policy(queue_name)
    create_queue(vhost, username, _decrypt(decryption_key, password.encode('ascii')), exchange_name,
                 queue_name, routing_key)
    sync_queue(queue_name)
    print('INFO: Done creating mirrored queues...')

def _set_ha_policy(queue_name):
    print('INFO: Setting HA policy for queue {}'.format(queue_name))
    command = f'{RABBITMQCTL} set_policy -p SSPL ha-{queue_name} ' + \
              f'"^{queue_name}$" \'{{"ha-mode":"all"}}\''
    print(command)
    _send_command(command)

def _get_connection_config(section, exchange_key=EXCHANGE_NAME_KEY,
                           queue_key=QUEUE_NAME_KEY, routing_key=ROUTING_KEY):
    vhost = get_sspl_config_value(key=VIRT_HOST_KEY, sect=section, default='SSPL')
    exchange_name = get_sspl_config_value(key=exchange_key, sect=section)
    queue_name = get_sspl_config_value(key=queue_key, sect=section)
    routing_key = get_sspl_config_value(key=routing_key, sect=section)
    username = get_sspl_config_value(key=RPMQ_USERNAME_KEY, sect=section)
    password = get_sspl_config_value(key=RPMQ_PASSWORD_KEY, sect=section)
    return vhost, username, password, exchange_name, queue_name, routing_key

def create_queue(vhost, username, password, exchange_name, queue_name, routing_key):
    creds = pika.PlainCredentials(username, password)
    connection = pika.BlockingConnection(
                        pika.ConnectionParameters(
                            host='localhost',
                            credentials=creds,
                            virtual_host=vhost,))
    channel = connection.channel()
    try:
        channel.queue_declare(queue=queue_name, durable=True)
    except Exception as e:
        print('ERROR: Exception in queue declaration: {}'.format(e))
    try:
        channel.exchange_declare(
            exchange=exchange_name,
            exchange_type='topic',
            durable=True,
        )
    except Exception as e:
        print('ERROR: Exception is exchange declaration: {}'.format(e))
    channel.queue_bind(
        queue=queue_name,
        exchange=exchange_name,
        routing_key=routing_key
    )
    connection.close()

def _create_vhost_if_necessary(virtual_host):
    """ Creates the specified vhost (if necessary).

    No action will occur if the vhost already exists.

    @type virtual_host:           string
    @param virtual_host:          The vhost to create.
    """
    cmd = [RABBITMQCTL, 'list_vhosts']
    vhosts = subprocess.check_output(cmd).decode("utf-8").split('\n')
    print(f'INFO: vhosts: {vhosts}')
    for vhost in vhosts[1:-1]:
        if vhost == virtual_host:
            return
    try:
        cmd = f'{RABBITMQCTL} add_vhost {virtual_host}'
        subprocess.check_output(cmd, shell=True, stderr=subprocess.PIPE)
    except subprocess.CalledProcessError as e:
        err_msg = e.stderr.decode('utf-8')
        print(f'ERROR: Sub process failed with error: {err_msg}')
        if 'vhost_already_exists' in err_msg:
            print('WARN: Not creating new RabbitMQ virtual host in as vhosts exists already')
        else:
            raise
    else:
        print(f'INFO: Created new virtual host {virtual_host} in RabbitMQ')

def _create_user_if_necessary(username, password, virtual_host):
    """ Create the rabbitmq user (if necessary).

    The user is created (if it doesn't exist) and then set with .* permissions
    for conf,write,read on the specified virtual_host.

    The permissions will be set regardless of whether or not the user already exists.

    The password will only be set if this is a new user.

    Note: To delete the user, from bash, run::
        rabbitmqctl delete_user <username>

    @type username:               string
    @param username:              The user to create.
    @type password:               string
    @param passowrd:              The password for the specified user.  Will
                                  only be set if this is a new user.
    @type virtual_host:           string
    @param virtual_host:          The vhost on which the permissions will be
                                  set.
    """
    cmd = [RABBITMQCTL, 'list_users']
    users = subprocess.check_output(cmd).decode("utf-8").split('\n')
    print('INFO: Users: {users}')
    found_user = False
    for userspec in users[1:-1]:
        user = userspec.split()[0]
        if user == username:
            found_user = True
            break
    if not found_user:
        try:
            cmd = f'{RABBITMQCTL} add_user {username} {password}'
            subprocess.check_output(cmd, shell=True, stderr=subprocess.PIPE)
        except subprocess.CalledProcessError as e:
            err_msg = e.stderr.decode('utf-8')
            print(f'ERROR: Sub process failed with error: {err_msg}')
            if 'user_already_exists' in err_msg:
                print(f'INFO: Not creating new user in RabbitMQ')
            else:
                raise
        else:
            print(f'INFO: Created new user {username} in RabbitMQ')
    subprocess.check_call(
        [
            RABBITMQCTL, 'set_permissions',
            '-p', virtual_host,
            username, '.*', '.*', '.*'
        ])
    subprocess.check_call(
        [RABBITMQCTL, 'set_user_tags', username, 'administrator']
        )

def _send_command(command, fail_on_error=True):
    print(f'Executing: {command}')
    process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    response, error = process.communicate()
    if process.returncode != 0:
        print("ERROR: command '%s' failed with error\n%s" % (command, error))
        if fail_on_error:
            sys.exit(1)
        else:
            return str(error)
    return str(response)

def _check_and_reset_rabbitmq():
    """Reset if the node is down"""
    command = "service rabbitmq-server status"
    response = _send_command(command)
    if "nodedown" in response:
        print("WARN: Nodedown, resetting")
        command = "pkill beam.smp"
        _send_command(command)

def _start_rabbitmq():
    """Ensure rabbitmq-server is started"""
    command = "service rabbitmq-server start"
    _send_command(command)

def _set_perms_erlang_key():
    # Set the ownership and permissions on cluster key
    command = "chown rabbitmq:rabbitmq /var/lib/rabbitmq/.erlang.cookie"
    _send_command(command)
    command = "chmod 400 /var/lib/rabbitmq/.erlang.cookie"
    _send_command(command)


if __name__ == '__main__':
    main()
